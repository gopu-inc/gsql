name: üöÄ Publication Automatique (Push Direct)

on:
  push:
    branches: [main]
    # IMPORTANT: Exclure les commits g√©n√©r√©s par le workflow lui-m√™me
    paths-ignore:
      - '**/__pycache__/**'
      - '**/*.log'
      - '**/.gitignore'

env:
  VERSION_FILE: "gsql/__init__.py"
  REPO: gopu-inc/gsql

permissions:
  contents: write  # CRITIQUE pour pouvoir push

jobs:
  # 1. CALCUL DE VERSION ET MISE √Ä JOUR
  bump-and-push:
    runs-on: ubuntu-latest
    # √âviter les boucles infinies : ne pas s'ex√©cuter sur les commits de version
    if: |
      github.event_name == 'push' && 
      github.ref == 'refs/heads/main' &&
      !contains(github.event.head_commit.message, '[skip ci]') &&
      !contains(github.event.head_commit.message, 'chore: bump version')
    
    steps:
      - name: üì• Checkout avec votre token GB_TOKEN
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GB_TOKEN }}
          fetch-depth: 0
      
      - name: üîç Lire la version actuelle
        id: read-version
        run: |
          if [ -f "$VERSION_FILE" ]; then
            CURRENT_VERSION=$(python -c "
            import re
            with open('$VERSION_FILE', 'r') as f:
                content = f.read()
                match = re.search(r'__version__\s*=\s*[\"]([^\"]+)[\"]', content)
                if match:
                    print(match.group(1))
            " 2>/dev/null || echo "")
          fi
          
          if [ -z "$CURRENT_VERSION" ]; then
            CURRENT_VERSION="0.1.0"
          fi
          
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "üìå Version actuelle: $CURRENT_VERSION"
      
      - name: üßÆ Calculer la nouvelle version
        id: calculate
        run: |
          CURRENT_VERSION="${{ steps.read-version.outputs.current_version }}"
          COMMIT_MSG=$(git log -1 --pretty=%B)
          
          echo "üìù Dernier commit: $COMMIT_MSG"
          
          # D√©terminer le type de mise √† jour
          if echo "$COMMIT_MSG" | grep -q -E "BREAKING CHANGE|feat!|major:"; then
            VERSION_TYPE="major"
            echo "üéØ MAJOR version bump"
          elif echo "$COMMIT_MSG" | grep -q -E "^feat:|^feature:|^enhancement:"; then
            VERSION_TYPE="minor"
            echo "üéØ MINOR version bump"
          else
            VERSION_TYPE="patch"
            echo "üéØ PATCH version bump"
          fi
          
          # Calculer la nouvelle version
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
          
          case "$VERSION_TYPE" in
            "major")
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            "minor")
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            "patch")
              PATCH=$((PATCH + 1))
              ;;
          esac
          
          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          
          # Si la version n'a pas chang√©, ne rien faire
          if [ "$CURRENT_VERSION" = "$NEW_VERSION" ]; then
            echo "‚ÑπÔ∏è Version inchang√©e, arr√™t du workflow"
            echo "new_version=" >> $GITHUB_OUTPUT
            echo "version_type=skip" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "version_type=$VERSION_TYPE" >> $GITHUB_OUTPUT
          echo "üìà Nouvelle version calcul√©e: $NEW_VERSION"
    
    outputs:
      current_version: ${{ steps.read-version.outputs.current_version }}
      new_version: ${{ steps.calculate.outputs.new_version }}
      version_type: ${{ steps.calculate.outputs.version_type }}

  # 2. MISE √Ä JOUR DES FICHIERS ET PUSH DIRECT
  update-and-push:
    needs: bump-and-push
    runs-on: ubuntu-latest
    # Ne s'ex√©cute que si une nouvelle version a √©t√© calcul√©e
    if: needs.bump-and-push.outputs.new_version != ''
    
    steps:
      - name: üì• Checkout avec token pour √©criture
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GB_TOKEN }}
          fetch-depth: 0
      
      - name: üîß Configuration Git
        run: |
          git config --global user.email "github-actions@${{ env.REPO }}"
          git config --global user.name "GitHub Actions"
          # Utiliser l'URL avec token pour le push
          git remote set-url origin https://x-access-token:${{ secrets.GB_TOKEN }}@github.com/${{ env.REPO }}.git
      
      - name: üîÑ Mettre √† jour TOUS les fichiers de version
        run: |
          OLD_VERSION="${{ needs.bump-and-push.outputs.current_version }}"
          NEW_VERSION="${{ needs.bump-and-push.outputs.new_version }}"
          
          echo "üîÑ Mise √† jour automatique: $OLD_VERSION ‚Üí $NEW_VERSION"
          
          # 1. Source de v√©rit√©: gsql/__init__.py
          sed -i "s/__version__ = [\"']$OLD_VERSION[\"']/__version__ = \"$NEW_VERSION\"/g" "$VERSION_FILE"
          echo "‚úÖ $VERSION_FILE mis √† jour"
          
          # 2. pyproject.toml
          for file in pyproject.toml setup.py setup.cfg; do
            if [ -f "$file" ]; then
              sed -i "s/version\s*=\s*[\"'][^\"']*[\"']/version = \"$NEW_VERSION\"/g" "$file" 2>/dev/null || true
              sed -i "s/version=['\"][^'\"]*['\"]/version='$NEW_VERSION'/g" "$file" 2>/dev/null || true
              echo "‚úÖ $file mis √† jour"
            fi
          done
          
          # 3. Dockerfile - CORRECTION CRITIQUE
          if [ -f "Dockerfile" ]; then
            # Correction du LABEL version (c'√©tait votre erreur)
            sed -i "s/LABEL version=.*/LABEL version=\"$NEW_VERSION\"/g" Dockerfile 2>/dev/null || true
            # Mettre √† jour ARG VERSION
            sed -i "s/ARG VERSION=.*/ARG VERSION=\"$NEW_VERSION\"/g" Dockerfile 2>/dev/null || true
            echo "‚úÖ Dockerfile mis √† jour (LABEL et ARG)"
          fi
          
          # 4. Anaconda meta.yaml
          if [ -f "conda.recipe/meta.yaml" ]; then
            sed -i "s/version:\s*[\"'][^\"']*[\"']/version: \"$NEW_VERSION\"/g" conda.recipe/meta.yaml
            sed -i "s/number:\s*[0-9]*/number: ${{ github.run_number }}/g" conda.recipe/meta.yaml
            echo "‚úÖ conda.recipe/meta.yaml mis √† jour"
          fi
          
          # 5. README.md
          if [ -f "README.md" ]; then
            sed -i "s/gsql==[0-9]\+\.[0-9]\+\.[0-9]\+/gsql==$NEW_VERSION/g" README.md 2>/dev/null || true
            sed -i "s/gsql:[0-9]\+\.[0-9]\+\.[0-9]\+/gsql:$NEW_VERSION/g" README.md 2>/dev/null || true
            sed -i "s/version [0-9]\+\.[0-9]\+\.[0-9]\+/version $NEW_VERSION/g" README.md 2>/dev/null || true
            echo "‚úÖ README.md mis √† jour"
          fi
      
      - name: üíæ Commit et Push direct dans main
        run: |
          NEW_VERSION="${{ needs.bump-and-push.outputs.new_version }}"
          
          # V√©rifier les changements
          echo "üìã Fichiers modifi√©s:"
          git status --short
          
          # Commit avec message sp√©cifique
          git add -A
          git commit -m "chore: bump version to $NEW_VERSION [skip ci]"
          
          # Push vers main
          echo "üöÄ Pushing version update to main branch..."
          git push origin HEAD:main
          
          echo "‚úÖ Version $NEW_VERSION pouss√©e dans main!"
      
      - name: üè∑Ô∏è Cr√©er et pousser le tag Git
        run: |
          NEW_VERSION="${{ needs.bump-and-push.outputs.new_version }}"
          TAG_NAME="v$NEW_VERSION"
          
          # Cr√©er le tag annot√©
          git tag -a "$TAG_NAME" -m "Release version $NEW_VERSION"
          
          # Pousser le tag (ceci d√©clenchera le workflow de publication)
          echo "üè∑Ô∏è Creating and pushing tag: $TAG_NAME"
          git push origin "$TAG_NAME"
          
          echo "‚úÖ Tag $TAG_NAME cr√©√© et pouss√©"
          echo "üîî Le workflow de publication va maintenant se d√©clencher automatiquement!"

  # 3. PUBLICATION MULTI-PLATEFORMES (d√©clench√© par les tags)
  publish-all-platforms:
    runs-on: ubuntu-latest
    # CE JOB S'EX√âCUTE SEULEMENT QUAND UN TAG EST PUSH√â
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')
    
    env:
      CLEAN_VERSION: ${{ github.ref_name }}
    
    steps:
      - name: üì• Checkout avec le tag
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: üîß V√©rifier la coh√©rence des versions
        run: |
          TAG_VERSION="${GITHUB_REF#refs/tags/v}"
          echo "üè∑Ô∏è Version du tag: $TAG_VERSION"
          
          # Lire la version du code
          if [ -f "$VERSION_FILE" ]; then
            CODE_VERSION=$(grep -E "__version__\s*=\s*[\"'][0-9]+\.[0-9]+\.[0-9]+[\"']" "$VERSION_FILE" | head -1 | sed -E "s/.*[\"']([0-9]+\.[0-9]+\.[0-9]+)[\"'].*/\1/")
          fi
          
          if [ "$TAG_VERSION" != "$CODE_VERSION" ]; then
            echo "‚ùå ERREUR: Version du tag ($TAG_VERSION) != version du code ($CODE_VERSION)"
            exit 1
          fi
          echo "‚úÖ Versions synchronis√©es: $TAG_VERSION"
      
      - name: üê≥ Publication Docker Hub
        uses: docker/login-action@v3
        with:
          username: ceoseshell
          password: ${{ secrets.DOCKER_PASSWORD }}
      
      - name: üê≥ Build & Push Docker Image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ceoseshell/gsql:latest
            ceoseshell/gsql:${{ env.CLEAN_VERSION }}
          labels: |
            version=${{ env.CLEAN_VERSION }}
            org.opencontainers.image.source=https://github.com/${{ env.REPO }}
            org.opencontainers.image.revision=${{ github.sha }}
      
      - name: üêç Publication PyPI
        run: |
          pip install build twine
          python -m build
          twine upload --username __token__ --password ${{ secrets.PYPI_TOKEN }} dist/*
      
      - name: üì¶ Publication Anaconda
        uses: conda-incubator/setup-miniconda@v3
        with:
          auto-activate-base: true
          python-version: 3.10
      
      - name: üèóÔ∏è Build Anaconda Package
        run: |
          conda install conda-build anaconda-client -y
          conda build conda.recipe/ --output-folder conda_pkg
      
      - name: üöÄ Upload vers Anaconda
        run: |
          PKG_FILE=$(find conda_pkg -name "*.tar.bz2" -type f | head -1)
          if [ -n "$PKG_FILE" ] && [ -f "$PKG_FILE" ]; then
            anaconda -t ${{ secrets.ANACONDA_TOKEN }} upload --user ceoseshell "$PKG_FILE"
          fi
      
      - name: üè∑Ô∏è GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ github.ref }}
          name: Release v${{ env.CLEAN_VERSION }}
          body: |
            ## üöÄ Version ${{ env.CLEAN_VERSION }}
            
            Publication automatique sur toutes les plateformes.
            
            ### üì¶ Installation
            
            **Docker:**
            ```bash
            docker pull ceoseshell/gsql:${{ env.CLEAN_VERSION }}
            ```
            
            **PyPI:**
            ```bash
            pip install gsql==${{ env.CLEAN_VERSION }}
            ```
            
            **Anaconda:**
            ```bash
            conda install -c ceoseshell gsql=${{ env.CLEAN_VERSION }}
            ```
            
            ### üîó Liens
            - [Documentation](https://github.com/${{ env.REPO }}/wiki)
            - [Code source](https://github.com/${{ env.REPO }}/tree/${{ github.ref }})
            
            *Auto-g√©n√©r√© le ${{ github.event.head_commit.timestamp }}*
          draft: false
          prerelease: false
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GB_TOKEN }}

  # 4. NOTIFICATION (Optionnel)
  notify:
    runs-on: ubuntu-latest
    needs: [update-and-push, publish-all-platforms]
    if: always()
    steps:
      - name: üìä Rapport de publication
        run: |
          echo "## üì¶ PUBLICATION AUTOMATIQUE TERMIN√âE" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ **Processus complet ex√©cut√© avec succ√®s**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîÑ Ce qui a √©t√© fait:" >> $GITHUB_STEP_SUMMARY
          echo "1. Calcul automatique de la nouvelle version" >> $GITHUB_STEP_SUMMARY
          echo "2. Mise √† jour de tous les fichiers (__init__.py, Dockerfile, etc.)" >> $GITHUB_STEP_SUMMARY
          echo "3. Commit et push direct dans la branche main" >> $GITHUB_STEP_SUMMARY
          echo "4. Cr√©ation automatique du tag Git" >> $GITHUB_STEP_SUMMARY
          echo "5. Publication sur Docker Hub, PyPI et Anaconda" >> $GITHUB_STEP_SUMMARY
          echo "6. Cr√©ation de la Release GitHub" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "üéâ **Toutes les plateformes sont maintenant synchronis√©es!**" >> $GITHUB_STEP_SUMMARY
