{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"api/database/","title":"Module database","text":"<p>Ce module g\u00e8re les connexions et les op\u00e9rations principales de la base de donn\u00e9es.</p>"},{"location":"api/database/#reference-des-fonctions","title":"R\u00e9f\u00e9rence des fonctions","text":"<p>GSQL Database Module - SQLite Backend Only Version: 3.0 - Auto-recovery, no YAML</p> <p>Ce module g\u00e8re les connexions et les op\u00e9rations principales de la base de donn\u00e9es.</p>"},{"location":"api/database/#gsql.database.Database","title":"<code>Database</code>","text":"<p>Base de donn\u00e9es SQLite auto-r\u00e9cup\u00e9rante</p> Source code in <code>gsql/database.py</code> <pre><code>class Database:\n    \"\"\"Base de donn\u00e9es SQLite auto-r\u00e9cup\u00e9rante\"\"\"\n\n    def __init__(self, db_path=None, base_dir=\"/root/.gsql\", \n                 buffer_pool_size=100, enable_wal=True, auto_recovery=True):\n        \"\"\"\n        Initialise la base de donn\u00e9es SQLite\n\n        Args:\n            db_path: Chemin de la base (None pour auto)\n            base_dir: R\u00e9pertoire de base pour GSQL\n            buffer_pool_size: Taille du buffer pool\n            enable_wal: Activer le mode WAL\n            auto_recovery: Activer la r\u00e9cup\u00e9ration automatique\n        \"\"\"\n        self.base_dir = Path(base_dir)\n        self.base_dir.mkdir(parents=True, exist_ok=True)\n\n        # Configuration\n        self.config = {\n            'db_path': db_path,\n            'base_dir': str(base_dir),\n            'buffer_pool_size': buffer_pool_size,\n            'enable_wal': enable_wal,\n            'auto_recovery': auto_recovery,\n            'auto_backup': True,\n            'backup_interval': 24 * 3600,  # 24 heures\n            'max_query_cache': 100,\n            'query_timeout': 30,  # secondes\n            'version': '3.0'\n        }\n\n        # Initialiser le moteur de stockage\n        self.storage = create_storage(\n            db_path=db_path,\n            base_dir=base_dir,\n            buffer_pool_size=buffer_pool_size,\n            enable_wal=enable_wal\n        )\n\n        # \u00c9tat de la base\n        self.is_open = True\n        self.initialized = False\n        self.lock = threading.RLock()\n\n        # Cache des r\u00e9sultats\n        self.query_cache = {}\n        self.schema_cache = {}\n\n        # Statistiques\n        self.stats = {\n            'queries_executed': 0,\n            'queries_cached': 0,\n            'transactions': 0,\n            'errors': 0,\n            'start_time': datetime.now(),\n            'last_backup': None\n        }\n\n        # Journal de transaction actif\n        self.active_transactions = {}\n\n        # Initialiser les tables syst\u00e8me\n        self._initialize_database()\n\n        logger.info(f\"GSQL Database initialized (v{self.config['version']})\")\n\n    def _save_config(self):\n        \"\"\"Sauvegarde la configuration dans un fichier JSON\"\"\"\n        config_file = self.base_dir / \"gsql_config.json\"\n        try:\n            with open(config_file, 'w') as f:\n                json.dump(self.config, f, indent=2)\n        except Exception as e:\n            logger.warning(f\"Failed to save config: {e}\")\n\n    def _initialize_database(self, skip_recovery=False):\n        \"\"\"Initialise les tables et structures syst\u00e8me\"\"\"\n        try:\n            with self.lock:\n                # V\u00e9rifier si les tables syst\u00e8me existent\n                tables = self.storage.get_tables()\n\n                # Cr\u00e9er des tables par d\u00e9faut si n\u00e9cessaire\n                default_tables = self._get_default_tables()\n\n                for table_name, table_sql in default_tables.items():\n                    table_exists = any(t['table_name'] == table_name for t in tables)\n\n                    if not table_exists:\n                        logger.info(f\"Creating default table: {table_name}\")\n                        self.storage.execute(table_sql)\n\n                self.initialized = True\n\n                # Sauvegarder la configuration\n                self._save_config()\n\n        except Exception as e:\n            logger.error(f\"Failed to initialize database: {e}\")\n            if self.config['auto_recovery'] and not skip_recovery:\n                logger.warning(\"Attempting auto-recovery...\")\n                self._auto_recover()\n            else:\n                raise\n\n    def _get_default_tables(self) -&gt; Dict[str, str]:\n        \"\"\"Retourne les tables par d\u00e9faut \u00e0 cr\u00e9er\"\"\"\n        return {\n            'users': \"\"\"\n                CREATE TABLE IF NOT EXISTS users (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    username TEXT UNIQUE NOT NULL,\n                    email TEXT UNIQUE NOT NULL,\n                    full_name TEXT,\n                    age INTEGER CHECK(age &gt;= 0),\n                    city TEXT DEFAULT 'Unknown',\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n                )\n            \"\"\",\n\n            'products': \"\"\"\n                CREATE TABLE IF NOT EXISTS products (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    name TEXT NOT NULL,\n                    description TEXT,\n                    price REAL NOT NULL CHECK(price &gt;= 0),\n                    category TEXT,\n                    stock INTEGER DEFAULT 0 CHECK(stock &gt;= 0),\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                    active BOOLEAN DEFAULT 1\n                )\n            \"\"\",\n\n            'orders': \"\"\"\n                CREATE TABLE IF NOT EXISTS orders (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    user_id INTEGER NOT NULL,\n                    product_id INTEGER NOT NULL,\n                    quantity INTEGER NOT NULL CHECK(quantity &gt; 0),\n                    total_price REAL NOT NULL CHECK(total_price &gt;= 0),\n                    status TEXT DEFAULT 'pending',\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,\n                    FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE CASCADE\n                )\n            \"\"\",\n\n            'logs': \"\"\"\n                CREATE TABLE IF NOT EXISTS logs (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    level TEXT NOT NULL,\n                    message TEXT NOT NULL,\n                    source TEXT,\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n                )\n            \"\"\"\n        }\n\n    def _auto_recover(self, recursion_depth=0):\n        \"\"\"Tente une r\u00e9cup\u00e9ration automatique avec limite de r\u00e9cursion\"\"\"\n        MAX_RECURSION = 3\n\n        if recursion_depth &gt;= MAX_RECURSION:\n            logger.error(f\"Max recursion depth ({MAX_RECURSION}) reached in auto-recovery\")\n            raise SQLExecutionError(\"Auto-recovery failed: max recursion depth exceeded\")\n\n        try:\n            logger.warning(f\"Starting auto-recovery (attempt {recursion_depth + 1})...\")\n\n            # Fermer et r\u00e9ouvrir le storage\n            if self.storage:\n                self.storage.close()\n\n            # R\u00e9initialiser le storage\n            self.storage = create_storage(\n                db_path=self.config['db_path'],\n                base_dir=self.config['base_dir'],\n                buffer_pool_size=self.config['buffer_pool_size'],\n                enable_wal=self.config['enable_wal']\n            )\n\n            # R\u00e9initialiser les tables SANS d\u00e9clencher une nouvelle r\u00e9cup\u00e9ration\n            self._initialize_database(skip_recovery=True)\n\n            logger.info(\"Auto-recovery completed successfully\")\n\n        except Exception as e:\n            logger.error(f\"Auto-recovery attempt {recursion_depth + 1} failed: {e}\")\n\n            # R\u00e9essayer si pas encore \u00e0 la limite\n            if recursion_depth &lt; MAX_RECURSION - 1:\n                wait_time = 1 * (2 ** recursion_depth)\n                time.sleep(wait_time)\n                return self._auto_recover(recursion_depth + 1)\n            else:\n                raise SQLExecutionError(f\"Database recovery failed after {MAX_RECURSION} attempts: {e}\")\n\n    def execute(self, sql: str, params: Dict = None,\n                use_cache: bool = True, timeout: int = None) -&gt; Dict:\n        \"\"\"\n        Ex\u00e9cute une requ\u00eate SQL sur la base de donn\u00e9es\n\n        Args:\n            sql: Requ\u00eate SQL \u00e0 ex\u00e9cuter\n            params: Param\u00e8tres pour la requ\u00eate pr\u00e9par\u00e9e\n            use_cache: Utiliser le cache de requ\u00eates\n            timeout: Timeout en secondes\n\n        Returns:\n            Dict: R\u00e9sultats format\u00e9s de la requ\u00eate\n        \"\"\"\n        if not self.is_open:\n            raise SQLExecutionError(\"Database is closed\")\n\n        # D\u00e9tecter les commandes sp\u00e9ciales GSQL\n        special_result = self._handle_special_commands(sql)\n        if special_result:\n            return special_result\n\n        # D\u00e9tecter les commandes sp\u00e9ciales GSQL\n        special_result = self._handle_special_commands(sql)\n        if special_result:\n            return special_result\n        start_time = datetime.now()\n        query_hash = None\n\n        # G\u00e9n\u00e9rer un hash pour le cache\n        if use_cache and params is None:\n            query_hash = hashlib.md5(sql.encode()).hexdigest()[:16]\n            cached = self.query_cache.get(query_hash)\n            if cached:\n                self.stats['queries_cached'] += 1\n                logger.debug(f\"Query cache hit: {query_hash}\")\n                return cached\n\n        try:\n            with self.lock:\n                # D\u00e9terminer le type de requ\u00eate bas\u00e9 sur le SQL\n                sql_upper = sql.upper().strip()\n                if sql_upper.startswith('SELECT'):\n                    query_type = 'select'\n                elif sql_upper.startswith('INSERT'):\n                    query_type = 'insert'\n                elif sql_upper.startswith('UPDATE'):\n                    query_type = 'update'\n                elif sql_upper.startswith('DELETE'):\n                    query_type = 'delete'\n                elif sql_upper.startswith('CREATE'):\n                    query_type = 'create'\n                elif sql_upper.startswith('DROP'):\n                    query_type = 'drop'\n                elif sql_upper.startswith('ALTER'):\n                    query_type = 'alter'\n                elif sql_upper.startswith('BEGIN'):\n                    query_type = 'begin'\n                elif sql_upper.startswith('COMMIT'):\n                    query_type = 'commit'\n                elif sql_upper.startswith('ROLLBACK'):\n                    query_type = 'rollback'\n                else:\n                    query_type = 'unknown'\n\n                # Ex\u00e9cuter la requ\u00eate via le storage\n                result = self.storage.execute(sql, params)\n\n                # Ajouter des m\u00e9tadonn\u00e9es\n                execution_time = (datetime.now() - start_time).total_seconds()\n                result['execution_time'] = round(execution_time, 3)\n                result['timestamp'] = datetime.now().isoformat()\n\n                # Ajouter le type de requ\u00eate au r\u00e9sultat\n                result['type'] = query_type\n\n                # Mettre \u00e0 jour les statistiques\n                self.stats['queries_executed'] += 1\n\n                # Mettre en cache les requ\u00eates SELECT r\u00e9ussies\n                if (use_cache and query_hash and \n                    result.get('success') and \n                    query_type == 'select'):\n\n                    # Limiter la taille du cache\n                    if len(self.query_cache) &gt;= self.config['max_query_cache']:\n                        # Supprimer la plus ancienne entr\u00e9e\n                        oldest_key = min(self.query_cache.keys(), \n                                        key=lambda k: self.query_cache[k]['timestamp'])\n                        del self.query_cache[oldest_key]\n\n                    self.query_cache[query_hash] = result\n\n                # Logger les requ\u00eates importantes\n                if execution_time &gt; 1.0:  # Plus d'1 seconde\n                    logger.warning(f\"Slow query ({execution_time:.2f}s): {sql[:100]}...\")\n\n                return result\n\n        except SQLExecutionError as e:\n            self.stats['errors'] += 1\n            logger.error(f\"Query execution error: {e}\")\n\n            # Tentative de r\u00e9cup\u00e9ration pour certaines erreurs\n            if \"database is locked\" in str(e) and self.config['auto_recovery']:\n                logger.info(\"Database locked, attempting recovery...\")\n                self._auto_recover()\n\n                # R\u00e9essayer la requ\u00eate\n                return self.execute(sql, params, use_cache=False)\n\n            raise\n\n        except Exception as e:\n            self.stats['errors'] += 1\n            logger.error(f\"Unexpected error: {e}\")\n            raise SQLExecutionError(f\"Database error: {str(e)}\")\n\n    def _handle_special_commands(self, sql: str) -&gt; Optional[Dict]:\n        logger.debug(f\"Checking special command: {sql}\")\n        \"\"\"G\u00e8re les commandes sp\u00e9ciales GSQL\"\"\"\n        sql_upper = sql.strip().upper()\n\n        # SHOW TABLES\n        if sql_upper == \"SHOW TABLES\" or sql == \".tables\":\n            return self._execute_show_tables()\n\n        # SHOW FUNCTIONS\n        elif sql_upper == \"SHOW FUNCTIONS\":\n            return self._execute_show_functions()\n\n        # DESCRIBE / SCHEMA\n        elif sql_upper.startswith(\"DESCRIBE \") or sql_upper.startswith(\"SCHEMA \"):\n            table_name = sql.split()[1] if len(sql.split()) &gt; 1 else None\n            if table_name:\n                return self._execute_describe_table(table_name)\n\n        # STATS\n        elif sql_upper == \"STATS\" or sql == \".stats\":\n            return self._execute_stats()\n\n        # VACUUM\n        elif sql_upper == \"VACUUM\":\n            return self._execute_vacuum()\n\n        # BACKUP\n        elif sql_upper.startswith(\"BACKUP\"):\n            return self._execute_backup(sql)\n\n        # HELP\n        elif sql_upper == \"HELP\" or sql == \".help\":\n            return self._execute_help()\n\n        return None\n\n    def _execute_show_tables(self) -&gt; Dict:\n        \"\"\"Ex\u00e9cute SHOW TABLES\"\"\"\n        try:\n            tables = self.storage.get_tables()\n\n            # Formater les r\u00e9sultats\n            formatted_tables = []\n            for table in tables:\n                formatted_tables.append({\n                    'table': table['table_name'],\n                    'rows': table.get('row_count', 0),\n                    'size_kb': round(table.get('size_bytes', 0) / 1024, 2),\n                    'columns': table.get('columns', []),\n                    'last_analyzed': table.get('last_analyzed')\n                })\n\n            return {\n                'type': 'show_tables',\n                'tables': formatted_tables,\n                'count': len(formatted_tables),\n                'message': f'Found {len(formatted_tables)} table(s)',\n                'success': True\n            }\n\n        except Exception as e:\n            return {\n                'type': 'show_tables',\n                'tables': [],\n                'count': 0,\n                'message': f'Error: {str(e)}',\n                'success': False\n            }\n\n    def _execute_show_functions(self) -&gt; Dict:\n        \"\"\"Ex\u00e9cute SHOW FUNCTIONS\"\"\"\n        try:\n            # R\u00e9cup\u00e9rer les fonctions depuis le storage\n            result = self.storage.execute(\"\"\"\n                SELECT name, params, returns, created_at, is_active\n                FROM _gsql_functions\n                WHERE is_active = 1\n                ORDER BY name\n            \"\"\")\n\n            # Ajouter les fonctions int\u00e9gr\u00e9es\n            builtin_funcs = [\n                {'name': 'UPPER(text)', 'type': 'builtin', 'description': 'Convert to uppercase'},\n                {'name': 'LOWER(text)', 'type': 'builtin', 'description': 'Convert to lowercase'},\n                {'name': 'LENGTH(text)', 'type': 'builtin', 'description': 'String length'},\n                {'name': 'ABS(number)', 'type': 'builtin', 'description': 'Absolute value'},\n                {'name': 'ROUND(number, decimals)', 'type': 'builtin', 'description': 'Round number'},\n                {'name': 'CONCAT(str1, str2, ...)', 'type': 'builtin', 'description': 'Concatenate strings'},\n                {'name': 'NOW()', 'type': 'builtin', 'description': 'Current timestamp'},\n                {'name': 'DATE()', 'type': 'builtin', 'description': 'Current date'}\n            ]\n\n            functions = []\n            if result['success'] and result['type'] == 'select':\n                for row in result['rows']:\n                    functions.append({\n                        'name': row['name'],\n                        'type': 'user',\n                        'params': json.loads(row['params']) if row['params'] else [],\n                        'returns': row['returns'],\n                        'created_at': row['created_at']\n                    })\n\n            functions.extend(builtin_funcs)\n\n            return {\n                'type': 'show_functions',\n                'functions': functions,\n                'count': len(functions),\n                'message': f'Found {len(functions)} function(s)',\n                'success': True\n            }\n\n        except Exception as e:\n            return {\n                'type': 'show_functions',\n                'functions': [],\n                'count': 0,\n                'message': f'Error: {str(e)}',\n                'success': False\n            }\n\n    def _execute_describe_table(self, table_name: str) -&gt; Dict:\n        \"\"\"Ex\u00e9cute DESCRIBE &lt;table&gt;\"\"\"\n        try:\n            schema = self.storage.get_table_schema(table_name)\n\n            if not schema:\n                raise SQLExecutionError(f\"Table '{table_name}' not found\")\n\n            # Formater le sch\u00e9ma\n            columns_info = []\n            for col_name, col_info in schema.get('columns', {}).items():\n                column_desc = f\"{col_name} {col_info.get('type', 'TEXT')}\"\n\n                if col_info.get('pk'):\n                    column_desc += \" PRIMARY KEY\"\n                if col_info.get('not_null'):\n                    column_desc += \" NOT NULL\"\n                if col_info.get('default'):\n                    column_desc += f\" DEFAULT {col_info['default']}\"\n\n                columns_info.append({\n                    'field': col_name,\n                    'type': col_info.get('type', 'TEXT'),\n                    'null': not col_info.get('not_null', False),\n                    'key': 'PRI' if col_info.get('pk') else '',\n                    'default': col_info.get('default'),\n                    'extra': 'auto_increment' if col_info.get('auto_increment') else ''\n                })\n\n            return {\n                'type': 'describe',\n                'table': table_name,\n                'columns': columns_info,\n                'indexes': schema.get('indexes', []),\n                'foreign_keys': schema.get('foreign_keys', []),\n                'count': len(columns_info),\n                'message': f'Table structure of {table_name}',\n                'success': True\n            }\n\n        except Exception as e:\n            return {\n                'type': 'describe',\n                'table': table_name,\n                'columns': [],\n                'message': f'Error: {str(e)}',\n                'success': False\n            }\n\n    def _execute_stats(self) -&gt; Dict:\n        \"\"\"Ex\u00e9cute STATS pour voir les statistiques\"\"\"\n        try:\n            # R\u00e9cup\u00e9rer les statistiques du storage\n            storage_stats = self.storage.get_stats()\n\n            # Statistiques de la base\n            db_stats = {\n                'queries_executed': self.stats['queries_executed'],\n                'queries_cached': self.stats['queries_cached'],\n                'cache_hit_ratio': (\n                    self.stats['queries_cached'] / self.stats['queries_executed'] \n                    if self.stats['queries_executed'] &gt; 0 else 0\n                ),\n                'errors': self.stats['errors'],\n                'uptime_seconds': (datetime.now() - self.stats['start_time']).total_seconds(),\n                'query_cache_size': len(self.query_cache),\n                'active_transactions': len(self.active_transactions)\n            }\n\n            return {\n                'type': 'stats',\n                'database': db_stats,\n                'storage': storage_stats,\n                'config': self.config,\n                'message': 'Database statistics',\n                'success': True\n            }\n\n        except Exception as e:\n            return {\n                'type': 'stats',\n                'message': f'Error: {str(e)}',\n                'success': False\n            }\n\n    def _execute_vacuum(self) -&gt; Dict:\n        \"\"\"Ex\u00e9cute VACUUM pour optimiser la base\"\"\"\n        try:\n            success = self.storage.vacuum()\n\n            return {\n                'type': 'vacuum',\n                'success': success,\n                'message': 'Database optimization completed' if success else 'Optimization failed'\n            }\n\n        except Exception as e:\n            return {\n                'type': 'vacuum',\n                'success': False,\n                'message': f'Error: {str(e)}'\n            }\n\n    def _execute_backup(self, sql: str) -&gt; Dict:\n        \"\"\"Ex\u00e9cute BACKUP [path]\"\"\"\n        try:\n            # Extraire le chemin optionnel\n            parts = sql.split()\n            backup_path = parts[1] if len(parts) &gt; 1 else None\n\n            # Cr\u00e9er la sauvegarde\n            backup_file = self.storage.backup(backup_path)\n\n            # Mettre \u00e0 jour les statistiques\n            self.stats['last_backup'] = datetime.now().isoformat()\n\n            return {\n                'type': 'backup',\n                'success': True,\n                'backup_file': backup_file,\n                'message': f'Backup created: {backup_file}'\n            }\n\n        except Exception as e:\n            return {\n                'type': 'backup',\n                'success': False,\n                'message': f'Error: {str(e)}'\n            }\n\n    def _execute_help(self) -&gt; Dict:\n        \"\"\"Ex\u00e9cute HELP pour afficher l'aide\"\"\"\n        help_text = \"\"\"\nGSQL Database Commands:\n\nDATA MANIPULATION:\n  SELECT * FROM table [WHERE condition] [LIMIT n]\n  INSERT INTO table (col1, col2) VALUES (val1, val2)\n  UPDATE table SET col=value [WHERE condition]\n  DELETE FROM table [WHERE condition]\n\nDATA DEFINITION:\n  CREATE TABLE name (col1 TYPE, col2 TYPE, ...)\n  DROP TABLE name\n  ALTER TABLE name ADD COLUMN col TYPE\n  CREATE INDEX idx_name ON table(column)\n\nDATABASE MANAGEMENT:\n  SHOW TABLES                    - List all tables\n  DESCRIBE table                 - Show table structure\n  SHOW FUNCTIONS                 - List all functions\n  STATS                          - Show database statistics\n  VACUUM                         - Optimize database\n  BACKUP [path]                  - Create database backup\n  HELP                           - This help message\n\nTRANSACTIONS:\n  BEGIN [DEFERRED|IMMEDIATE|EXCLUSIVE]\n  COMMIT\n  ROLLBACK [TO SAVEPOINT name]\n  SAVEPOINT name\n\nDOT COMMANDS (compatible SQLite):\n  .tables                        - List tables\n  .schema [table]                - Show schema\n  .stats                         - Show stats\n  .help                          - Show help\n  .backup [file]                 - Create backup\n  .vacuum                        - Optimize database\n\"\"\"\n\n        return {\n            'type': 'help',\n            'message': help_text,\n            'success': True\n        }\n\n    # ==================== TRANSACTION MANAGEMENT ====================\n\n    def begin_transaction(self, isolation_level: str = \"DEFERRED\") -&gt; Dict:\n        \"\"\"D\u00e9marre une nouvelle transaction\"\"\"\n        try:\n            tid = self.storage.begin_transaction(isolation_level)\n\n            # Enregistrer la transaction\n            self.active_transactions[tid] = {\n                'start_time': datetime.now(),\n                'isolation': isolation_level,\n                'queries': []\n            }\n\n            self.stats['transactions'] += 1\n\n            return {\n                'type': 'transaction',\n                'tid': tid,\n                'isolation': isolation_level,\n                'message': f'Transaction {tid} started',\n                'success': True\n            }\n\n        except Exception as e:\n            raise TransactionError(f\"Failed to begin transaction: {e}\")\n\n    def commit_transaction(self, tid: int) -&gt; Dict:\n        \"\"\"Valide une transaction\"\"\"\n        try:\n            success = self.storage.commit_transaction(tid)\n\n            if tid in self.active_transactions:\n                del self.active_transactions[tid]\n\n            return {\n                'type': 'transaction',\n                'tid': tid,\n                'message': f'Transaction {tid} committed',\n                'success': success\n            }\n\n        except Exception as e:\n            raise TransactionError(f\"Failed to commit transaction {tid}: {e}\")\n\n    def rollback_transaction(self, tid: int, to_savepoint: str = None) -&gt; Dict:\n        \"\"\"Annule une transaction\"\"\"\n        try:\n            success = self.storage.rollback_transaction(tid, to_savepoint)\n\n            if not to_savepoint and tid in self.active_transactions:\n                del self.active_transactions[tid]\n\n            return {\n                'type': 'transaction',\n                'tid': tid,\n                'message': f'Transaction {tid} rolled back' + \n                          (f' to {to_savepoint}' if to_savepoint else ''),\n                'success': success\n            }\n\n        except Exception as e:\n            raise TransactionError(f\"Failed to rollback transaction {tid}: {e}\")\n\n    def create_savepoint(self, tid: int, name: str) -&gt; Dict:\n        \"\"\"Cr\u00e9e un savepoint dans une transaction\"\"\"\n        try:\n            success = self.storage.savepoint(tid, name)\n\n            if tid in self.active_transactions:\n                self.active_transactions[tid]['savepoints'] = \\\n                    self.active_transactions[tid].get('savepoints', []) + [name]\n\n            return {\n                'type': 'savepoint',\n                'tid': tid,\n                'name': name,\n                'message': f'Savepoint {name} created in transaction {tid}',\n                'success': success\n            }\n\n        except Exception as e:\n            raise TransactionError(f\"Failed to create savepoint: {e}\")\n\n    # ==================== TABLE MANAGEMENT ====================\n\n    def create_table(self, table_name: str, columns: Dict) -&gt; Dict:\n        \"\"\"Cr\u00e9e une nouvelle table avec validation\"\"\"\n        try:\n            # Valider le nom de la table\n            if not re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', table_name):\n                raise SQLSyntaxError(f\"Invalid table name: '{table_name}'\")\n\n            # Construire la requ\u00eate SQL\n            column_defs = []\n            for col_name, col_spec in columns.items():\n                if isinstance(col_spec, str):\n                    col_def = f\"{col_name} {col_spec}\"\n                elif isinstance(col_spec, dict):\n                    col_def = f\"{col_name} {col_spec.get('type', 'TEXT')}\"\n\n                    if col_spec.get('primary_key'):\n                        col_def += \" PRIMARY KEY\"\n                    if col_spec.get('auto_increment'):\n                        col_def += \" AUTOINCREMENT\"\n                    if col_spec.get('not_null'):\n                        col_def += \" NOT NULL\"\n                    if 'default' in col_spec:\n                        default_val = col_spec['default']\n                        if isinstance(default_val, str) and not default_val.upper() in ['CURRENT_TIMESTAMP', 'NULL']:\n                            default_val = f\"'{default_val}'\"\n                        col_def += f\" DEFAULT {default_val}\"\n                    if col_spec.get('unique'):\n                        col_def += \" UNIQUE\"\n                    if 'check' in col_spec:\n                        col_def += f\" CHECK({col_spec['check']})\"\n                else:\n                    raise SQLSyntaxError(f\"Invalid column specification for '{col_name}'\")\n\n                column_defs.append(col_def)\n\n            sql = f\"CREATE TABLE {table_name} ({', '.join(column_defs)})\"\n\n            # Ex\u00e9cuter la cr\u00e9ation\n            result = self.execute(sql)\n\n            # Mettre \u00e0 jour le cache de sch\u00e9ma\n            self.storage._cache_table_schema(table_name)\n\n            return {\n                'type': 'create_table',\n                'table': table_name,\n                'columns': list(columns.keys()),\n                'sql': sql,\n                'message': f'Table {table_name} created successfully',\n                'success': True\n            }\n\n        except Exception as e:\n            raise SQLExecutionError(f\"Failed to create table {table_name}: {e}\")\n\n    def drop_table(self, table_name: str, if_exists: bool = True) -&gt; Dict:\n        \"\"\"Supprime une table\"\"\"\n        try:\n            sql = f\"DROP TABLE {'IF EXISTS ' if if_exists else ''}{table_name}\"\n            result = self.execute(sql)\n\n            # Nettoyer le cache\n            if table_name in self.schema_cache:\n                del self.schema_cache[table_name]\n\n            return {\n                'type': 'drop_table',\n                'table': table_name,\n                'message': f'Table {table_name} dropped',\n                'success': True\n            }\n\n        except Exception as e:\n            raise SQLExecutionError(f\"Failed to drop table {table_name}: {e}\")\n\n    def insert(self, table_name: str, values: Dict, \n               returning: str = None) -&gt; Dict:\n        \"\"\"Ins\u00e8re une ligne dans une table\"\"\"\n        try:\n            # Construire la requ\u00eate INSERT\n            columns = ', '.join(values.keys())\n            placeholders = ', '.join(['?' for _ in values])\n\n            sql = f\"INSERT INTO {table_name} ({columns}) VALUES ({placeholders})\"\n\n            if returning:\n                sql += f\" RETURNING {returning}\"\n\n            # Ex\u00e9cuter avec les valeurs\n            result = self.execute(sql, tuple(values.values()))\n\n            return {\n                'type': 'insert',\n                'table': table_name,\n                'lastrowid': result.get('lastrowid'),\n                'rows_affected': result.get('rows_affected', 0),\n                'message': f'Row inserted into {table_name}',\n                'success': True\n            }\n\n        except Exception as e:\n            raise SQLExecutionError(f\"Failed to insert into {table_name}: {e}\")\n\n    def select(self, table_name: str, columns: List[str] = None, \n               where: Dict = None, limit: int = None, \n               offset: int = 0, order_by: str = None) -&gt; Dict:\n        \"\"\"Ex\u00e9cute une requ\u00eate SELECT avec param\u00e8tres simplifi\u00e9s\"\"\"\n        try:\n            # Construire la requ\u00eate SELECT\n            cols = ', '.join(columns) if columns else '*'\n            sql = f\"SELECT {cols} FROM {table_name}\"\n\n            # Ajouter WHERE\n            params = []\n            if where:\n                conditions = []\n                for col, val in where.items():\n                    if isinstance(val, (list, tuple)):\n                        placeholders = ', '.join(['?' for _ in val])\n                        conditions.append(f\"{col} IN ({placeholders})\")\n                        params.extend(val)\n                    else:\n                        conditions.append(f\"{col} = ?\")\n                        params.append(val)\n\n                if conditions:\n                    sql += f\" WHERE {' AND '.join(conditions)}\"\n\n            # Ajouter ORDER BY\n            if order_by:\n                sql += f\" ORDER BY {order_by}\"\n\n            # Ajouter LIMIT et OFFSET\n            if limit is not None:\n                sql += f\" LIMIT {limit}\"\n                if offset:\n                    sql += f\" OFFSET {offset}\"\n\n            # Ex\u00e9cuter la requ\u00eate\n            result = self.execute(sql, params if params else None)\n\n            return result\n\n        except Exception as e:\n            raise SQLExecutionError(f\"Failed to select from {table_name}: {e}\")\n\n    # ==================== FUNCTION MANAGEMENT ====================\n\n    def register_function(self, name: str, func, num_params: int = -1) -&gt; Dict:\n        \"\"\"Enregistre une fonction Python dans la base\"\"\"\n        try:\n            self.storage.register_function(name, func, num_params)\n\n            return {\n                'type': 'register_function',\n                'name': name,\n                'num_params': num_params,\n                'message': f'Function {name} registered',\n                'success': True\n            }\n\n        except Exception as e:\n            raise FunctionError(f\"Failed to register function {name}: {e}\")\n\n    # ==================== MAINTENANCE ====================\n\n    def optimize(self) -&gt; Dict:\n        \"\"\"Optimise la base de donn\u00e9es\"\"\"\n        try:\n            # Ex\u00e9cuter plusieurs optimisations\n            results = []\n\n            # 1. VACUUM\n            vacuum_result = self._execute_vacuum()\n            results.append(('vacuum', vacuum_result['success']))\n\n            # 2. ANALYZE pour les statistiques\n            analyze_result = self.execute(\"ANALYZE\")\n            results.append(('analyze', analyze_result.get('success', False)))\n\n            # 3. Nettoyer le cache\n            self.query_cache.clear()\n            results.append(('clear_cache', True))\n\n            # 4. Nettoyer le buffer pool\n            self.storage.buffer_pool.invalidate()\n            results.append(('clear_buffer_pool', True))\n\n            return {\n                'type': 'optimize',\n                'operations': results,\n                'message': 'Database optimization completed',\n                'success': all(r[1] for r in results)\n            }\n\n        except Exception as e:\n            return {\n                'type': 'optimize',\n                'message': f'Error during optimization: {e}',\n                'success': False\n            }\n\n    def check_health(self) -&gt; Dict:\n        \"\"\"V\u00e9rifie la sant\u00e9 de la base de donn\u00e9es\"\"\"\n        try:\n            health_checks = []\n\n            # 1. Connexion\n            health_checks.append(('connection', self.is_open and self.storage.is_connected))\n\n            # 2. Tables syst\u00e8me\n            sys_tables = ['_gsql_metadata', '_gsql_schemas', '_gsql_functions']\n            for table in sys_tables:\n                result = self.execute(f\"SELECT 1 FROM {table} LIMIT 1\")\n                health_checks.append((f'table_{table}', result.get('success', False)))\n\n            # 3. Buffer pool\n            bp_stats = self.storage.buffer_pool.get_stats()\n            health_checks.append(('buffer_pool', bp_stats['hit_ratio'] &gt; 0.5))\n\n            # 4. Espace disque (estimation)\n            import shutil\n            disk_usage = shutil.disk_usage(self.base_dir)\n            free_gb = disk_usage.free / (1024**3)\n            health_checks.append(('disk_space', free_gb &gt; 1))  # 1GB minimum\n\n            # Calculer le score de sant\u00e9\n            passed = sum(1 for _, status in health_checks if status)\n            total = len(health_checks)\n            health_score = (passed / total) * 100\n\n            status = 'HEALTHY' if health_score &gt;= 80 else 'DEGRADED' if health_score &gt;= 50 else 'CRITICAL'\n\n            return {\n                'type': 'health_check',\n                'status': status,\n                'score': round(health_score, 1),\n                'checks': health_checks,\n                'passed': passed,\n                'total': total,\n                'message': f'Health check: {status} ({health_score:.1f}%)',\n                'success': health_score &gt;= 50\n            }\n\n        except Exception as e:\n            return {\n                'type': 'health_check',\n                'status': 'ERROR',\n                'score': 0,\n                'message': f'Health check failed: {e}',\n                'success': False\n            }\n\n    def close(self):\n        \"\"\"Ferme la base de donn\u00e9es proprement\"\"\"\n        with self.lock:\n            if self.is_open:\n                try:\n                    # Sauvegarder les statistiques\n                    self._save_stats()\n\n                    # Fermer le storage\n                    self.storage.close()\n\n                    # Fermer les transactions actives\n                    for tid in list(self.active_transactions.keys()):\n                        try:\n                            self.rollback_transaction(tid)\n                        except:\n                            pass\n\n                    self.is_open = False\n                    self.initialized = False\n\n                    logger.info(\"Database closed\")\n\n                except Exception as e:\n                    logger.error(f\"Error closing database: {e}\")\n\n    def _save_stats(self):\n        \"\"\"Sauvegarde les statistiques d'utilisation\"\"\"\n        stats_file = self.base_dir / \"gsql_stats.json\"\n        try:\n            # Convertir datetime en cha\u00eene pour JSON\n            stats_data = {\n                'stats': {\n                    'queries_executed': self.stats['queries_executed'],\n                    'queries_cached': self.stats['queries_cached'],\n                    'transactions': self.stats['transactions'],\n                    'errors': self.stats['errors'],\n                    'start_time': self.stats['start_time'].isoformat() if hasattr(self.stats['start_time'], 'isoformat') else str(self.stats['start_time']),\n                    'last_backup': self.stats['last_backup']\n                },\n                'last_run': datetime.now().isoformat(),\n                'version': self.config['version']\n            }\n\n            with open(stats_file, 'w') as f:\n                json.dump(stats_data, f, indent=2, default=str)\n\n        except Exception as e:\n            logger.warning(f\"Failed to save stats: {e}\")\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.close()\n\n    def __del__(self):\n        try:\n            self.close()\n        except:\n            pass\n</code></pre>"},{"location":"api/database/#gsql.database.Database.__init__","title":"<code>__init__(db_path=None, base_dir='/root/.gsql', buffer_pool_size=100, enable_wal=True, auto_recovery=True)</code>","text":"<p>Initialise la base de donn\u00e9es SQLite</p> <p>Parameters:</p> Name Type Description Default <code>db_path</code> <p>Chemin de la base (None pour auto)</p> <code>None</code> <code>base_dir</code> <p>R\u00e9pertoire de base pour GSQL</p> <code>'/root/.gsql'</code> <code>buffer_pool_size</code> <p>Taille du buffer pool</p> <code>100</code> <code>enable_wal</code> <p>Activer le mode WAL</p> <code>True</code> <code>auto_recovery</code> <p>Activer la r\u00e9cup\u00e9ration automatique</p> <code>True</code> Source code in <code>gsql/database.py</code> <pre><code>def __init__(self, db_path=None, base_dir=\"/root/.gsql\", \n             buffer_pool_size=100, enable_wal=True, auto_recovery=True):\n    \"\"\"\n    Initialise la base de donn\u00e9es SQLite\n\n    Args:\n        db_path: Chemin de la base (None pour auto)\n        base_dir: R\u00e9pertoire de base pour GSQL\n        buffer_pool_size: Taille du buffer pool\n        enable_wal: Activer le mode WAL\n        auto_recovery: Activer la r\u00e9cup\u00e9ration automatique\n    \"\"\"\n    self.base_dir = Path(base_dir)\n    self.base_dir.mkdir(parents=True, exist_ok=True)\n\n    # Configuration\n    self.config = {\n        'db_path': db_path,\n        'base_dir': str(base_dir),\n        'buffer_pool_size': buffer_pool_size,\n        'enable_wal': enable_wal,\n        'auto_recovery': auto_recovery,\n        'auto_backup': True,\n        'backup_interval': 24 * 3600,  # 24 heures\n        'max_query_cache': 100,\n        'query_timeout': 30,  # secondes\n        'version': '3.0'\n    }\n\n    # Initialiser le moteur de stockage\n    self.storage = create_storage(\n        db_path=db_path,\n        base_dir=base_dir,\n        buffer_pool_size=buffer_pool_size,\n        enable_wal=enable_wal\n    )\n\n    # \u00c9tat de la base\n    self.is_open = True\n    self.initialized = False\n    self.lock = threading.RLock()\n\n    # Cache des r\u00e9sultats\n    self.query_cache = {}\n    self.schema_cache = {}\n\n    # Statistiques\n    self.stats = {\n        'queries_executed': 0,\n        'queries_cached': 0,\n        'transactions': 0,\n        'errors': 0,\n        'start_time': datetime.now(),\n        'last_backup': None\n    }\n\n    # Journal de transaction actif\n    self.active_transactions = {}\n\n    # Initialiser les tables syst\u00e8me\n    self._initialize_database()\n\n    logger.info(f\"GSQL Database initialized (v{self.config['version']})\")\n</code></pre>"},{"location":"api/database/#gsql.database.Database.begin_transaction","title":"<code>begin_transaction(isolation_level='DEFERRED')</code>","text":"<p>D\u00e9marre une nouvelle transaction</p> Source code in <code>gsql/database.py</code> <pre><code>def begin_transaction(self, isolation_level: str = \"DEFERRED\") -&gt; Dict:\n    \"\"\"D\u00e9marre une nouvelle transaction\"\"\"\n    try:\n        tid = self.storage.begin_transaction(isolation_level)\n\n        # Enregistrer la transaction\n        self.active_transactions[tid] = {\n            'start_time': datetime.now(),\n            'isolation': isolation_level,\n            'queries': []\n        }\n\n        self.stats['transactions'] += 1\n\n        return {\n            'type': 'transaction',\n            'tid': tid,\n            'isolation': isolation_level,\n            'message': f'Transaction {tid} started',\n            'success': True\n        }\n\n    except Exception as e:\n        raise TransactionError(f\"Failed to begin transaction: {e}\")\n</code></pre>"},{"location":"api/database/#gsql.database.Database.check_health","title":"<code>check_health()</code>","text":"<p>V\u00e9rifie la sant\u00e9 de la base de donn\u00e9es</p> Source code in <code>gsql/database.py</code> <pre><code>def check_health(self) -&gt; Dict:\n    \"\"\"V\u00e9rifie la sant\u00e9 de la base de donn\u00e9es\"\"\"\n    try:\n        health_checks = []\n\n        # 1. Connexion\n        health_checks.append(('connection', self.is_open and self.storage.is_connected))\n\n        # 2. Tables syst\u00e8me\n        sys_tables = ['_gsql_metadata', '_gsql_schemas', '_gsql_functions']\n        for table in sys_tables:\n            result = self.execute(f\"SELECT 1 FROM {table} LIMIT 1\")\n            health_checks.append((f'table_{table}', result.get('success', False)))\n\n        # 3. Buffer pool\n        bp_stats = self.storage.buffer_pool.get_stats()\n        health_checks.append(('buffer_pool', bp_stats['hit_ratio'] &gt; 0.5))\n\n        # 4. Espace disque (estimation)\n        import shutil\n        disk_usage = shutil.disk_usage(self.base_dir)\n        free_gb = disk_usage.free / (1024**3)\n        health_checks.append(('disk_space', free_gb &gt; 1))  # 1GB minimum\n\n        # Calculer le score de sant\u00e9\n        passed = sum(1 for _, status in health_checks if status)\n        total = len(health_checks)\n        health_score = (passed / total) * 100\n\n        status = 'HEALTHY' if health_score &gt;= 80 else 'DEGRADED' if health_score &gt;= 50 else 'CRITICAL'\n\n        return {\n            'type': 'health_check',\n            'status': status,\n            'score': round(health_score, 1),\n            'checks': health_checks,\n            'passed': passed,\n            'total': total,\n            'message': f'Health check: {status} ({health_score:.1f}%)',\n            'success': health_score &gt;= 50\n        }\n\n    except Exception as e:\n        return {\n            'type': 'health_check',\n            'status': 'ERROR',\n            'score': 0,\n            'message': f'Health check failed: {e}',\n            'success': False\n        }\n</code></pre>"},{"location":"api/database/#gsql.database.Database.close","title":"<code>close()</code>","text":"<p>Ferme la base de donn\u00e9es proprement</p> Source code in <code>gsql/database.py</code> <pre><code>def close(self):\n    \"\"\"Ferme la base de donn\u00e9es proprement\"\"\"\n    with self.lock:\n        if self.is_open:\n            try:\n                # Sauvegarder les statistiques\n                self._save_stats()\n\n                # Fermer le storage\n                self.storage.close()\n\n                # Fermer les transactions actives\n                for tid in list(self.active_transactions.keys()):\n                    try:\n                        self.rollback_transaction(tid)\n                    except:\n                        pass\n\n                self.is_open = False\n                self.initialized = False\n\n                logger.info(\"Database closed\")\n\n            except Exception as e:\n                logger.error(f\"Error closing database: {e}\")\n</code></pre>"},{"location":"api/database/#gsql.database.Database.commit_transaction","title":"<code>commit_transaction(tid)</code>","text":"<p>Valide une transaction</p> Source code in <code>gsql/database.py</code> <pre><code>def commit_transaction(self, tid: int) -&gt; Dict:\n    \"\"\"Valide une transaction\"\"\"\n    try:\n        success = self.storage.commit_transaction(tid)\n\n        if tid in self.active_transactions:\n            del self.active_transactions[tid]\n\n        return {\n            'type': 'transaction',\n            'tid': tid,\n            'message': f'Transaction {tid} committed',\n            'success': success\n        }\n\n    except Exception as e:\n        raise TransactionError(f\"Failed to commit transaction {tid}: {e}\")\n</code></pre>"},{"location":"api/database/#gsql.database.Database.create_savepoint","title":"<code>create_savepoint(tid, name)</code>","text":"<p>Cr\u00e9e un savepoint dans une transaction</p> Source code in <code>gsql/database.py</code> <pre><code>def create_savepoint(self, tid: int, name: str) -&gt; Dict:\n    \"\"\"Cr\u00e9e un savepoint dans une transaction\"\"\"\n    try:\n        success = self.storage.savepoint(tid, name)\n\n        if tid in self.active_transactions:\n            self.active_transactions[tid]['savepoints'] = \\\n                self.active_transactions[tid].get('savepoints', []) + [name]\n\n        return {\n            'type': 'savepoint',\n            'tid': tid,\n            'name': name,\n            'message': f'Savepoint {name} created in transaction {tid}',\n            'success': success\n        }\n\n    except Exception as e:\n        raise TransactionError(f\"Failed to create savepoint: {e}\")\n</code></pre>"},{"location":"api/database/#gsql.database.Database.create_table","title":"<code>create_table(table_name, columns)</code>","text":"<p>Cr\u00e9e une nouvelle table avec validation</p> Source code in <code>gsql/database.py</code> <pre><code>def create_table(self, table_name: str, columns: Dict) -&gt; Dict:\n    \"\"\"Cr\u00e9e une nouvelle table avec validation\"\"\"\n    try:\n        # Valider le nom de la table\n        if not re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', table_name):\n            raise SQLSyntaxError(f\"Invalid table name: '{table_name}'\")\n\n        # Construire la requ\u00eate SQL\n        column_defs = []\n        for col_name, col_spec in columns.items():\n            if isinstance(col_spec, str):\n                col_def = f\"{col_name} {col_spec}\"\n            elif isinstance(col_spec, dict):\n                col_def = f\"{col_name} {col_spec.get('type', 'TEXT')}\"\n\n                if col_spec.get('primary_key'):\n                    col_def += \" PRIMARY KEY\"\n                if col_spec.get('auto_increment'):\n                    col_def += \" AUTOINCREMENT\"\n                if col_spec.get('not_null'):\n                    col_def += \" NOT NULL\"\n                if 'default' in col_spec:\n                    default_val = col_spec['default']\n                    if isinstance(default_val, str) and not default_val.upper() in ['CURRENT_TIMESTAMP', 'NULL']:\n                        default_val = f\"'{default_val}'\"\n                    col_def += f\" DEFAULT {default_val}\"\n                if col_spec.get('unique'):\n                    col_def += \" UNIQUE\"\n                if 'check' in col_spec:\n                    col_def += f\" CHECK({col_spec['check']})\"\n            else:\n                raise SQLSyntaxError(f\"Invalid column specification for '{col_name}'\")\n\n            column_defs.append(col_def)\n\n        sql = f\"CREATE TABLE {table_name} ({', '.join(column_defs)})\"\n\n        # Ex\u00e9cuter la cr\u00e9ation\n        result = self.execute(sql)\n\n        # Mettre \u00e0 jour le cache de sch\u00e9ma\n        self.storage._cache_table_schema(table_name)\n\n        return {\n            'type': 'create_table',\n            'table': table_name,\n            'columns': list(columns.keys()),\n            'sql': sql,\n            'message': f'Table {table_name} created successfully',\n            'success': True\n        }\n\n    except Exception as e:\n        raise SQLExecutionError(f\"Failed to create table {table_name}: {e}\")\n</code></pre>"},{"location":"api/database/#gsql.database.Database.drop_table","title":"<code>drop_table(table_name, if_exists=True)</code>","text":"<p>Supprime une table</p> Source code in <code>gsql/database.py</code> <pre><code>def drop_table(self, table_name: str, if_exists: bool = True) -&gt; Dict:\n    \"\"\"Supprime une table\"\"\"\n    try:\n        sql = f\"DROP TABLE {'IF EXISTS ' if if_exists else ''}{table_name}\"\n        result = self.execute(sql)\n\n        # Nettoyer le cache\n        if table_name in self.schema_cache:\n            del self.schema_cache[table_name]\n\n        return {\n            'type': 'drop_table',\n            'table': table_name,\n            'message': f'Table {table_name} dropped',\n            'success': True\n        }\n\n    except Exception as e:\n        raise SQLExecutionError(f\"Failed to drop table {table_name}: {e}\")\n</code></pre>"},{"location":"api/database/#gsql.database.Database.execute","title":"<code>execute(sql, params=None, use_cache=True, timeout=None)</code>","text":"<p>Ex\u00e9cute une requ\u00eate SQL sur la base de donn\u00e9es</p> <p>Parameters:</p> Name Type Description Default <code>sql</code> <code>str</code> <p>Requ\u00eate SQL \u00e0 ex\u00e9cuter</p> required <code>params</code> <code>Dict</code> <p>Param\u00e8tres pour la requ\u00eate pr\u00e9par\u00e9e</p> <code>None</code> <code>use_cache</code> <code>bool</code> <p>Utiliser le cache de requ\u00eates</p> <code>True</code> <code>timeout</code> <code>int</code> <p>Timeout en secondes</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict</code> <p>R\u00e9sultats format\u00e9s de la requ\u00eate</p> Source code in <code>gsql/database.py</code> <pre><code>def execute(self, sql: str, params: Dict = None,\n            use_cache: bool = True, timeout: int = None) -&gt; Dict:\n    \"\"\"\n    Ex\u00e9cute une requ\u00eate SQL sur la base de donn\u00e9es\n\n    Args:\n        sql: Requ\u00eate SQL \u00e0 ex\u00e9cuter\n        params: Param\u00e8tres pour la requ\u00eate pr\u00e9par\u00e9e\n        use_cache: Utiliser le cache de requ\u00eates\n        timeout: Timeout en secondes\n\n    Returns:\n        Dict: R\u00e9sultats format\u00e9s de la requ\u00eate\n    \"\"\"\n    if not self.is_open:\n        raise SQLExecutionError(\"Database is closed\")\n\n    # D\u00e9tecter les commandes sp\u00e9ciales GSQL\n    special_result = self._handle_special_commands(sql)\n    if special_result:\n        return special_result\n\n    # D\u00e9tecter les commandes sp\u00e9ciales GSQL\n    special_result = self._handle_special_commands(sql)\n    if special_result:\n        return special_result\n    start_time = datetime.now()\n    query_hash = None\n\n    # G\u00e9n\u00e9rer un hash pour le cache\n    if use_cache and params is None:\n        query_hash = hashlib.md5(sql.encode()).hexdigest()[:16]\n        cached = self.query_cache.get(query_hash)\n        if cached:\n            self.stats['queries_cached'] += 1\n            logger.debug(f\"Query cache hit: {query_hash}\")\n            return cached\n\n    try:\n        with self.lock:\n            # D\u00e9terminer le type de requ\u00eate bas\u00e9 sur le SQL\n            sql_upper = sql.upper().strip()\n            if sql_upper.startswith('SELECT'):\n                query_type = 'select'\n            elif sql_upper.startswith('INSERT'):\n                query_type = 'insert'\n            elif sql_upper.startswith('UPDATE'):\n                query_type = 'update'\n            elif sql_upper.startswith('DELETE'):\n                query_type = 'delete'\n            elif sql_upper.startswith('CREATE'):\n                query_type = 'create'\n            elif sql_upper.startswith('DROP'):\n                query_type = 'drop'\n            elif sql_upper.startswith('ALTER'):\n                query_type = 'alter'\n            elif sql_upper.startswith('BEGIN'):\n                query_type = 'begin'\n            elif sql_upper.startswith('COMMIT'):\n                query_type = 'commit'\n            elif sql_upper.startswith('ROLLBACK'):\n                query_type = 'rollback'\n            else:\n                query_type = 'unknown'\n\n            # Ex\u00e9cuter la requ\u00eate via le storage\n            result = self.storage.execute(sql, params)\n\n            # Ajouter des m\u00e9tadonn\u00e9es\n            execution_time = (datetime.now() - start_time).total_seconds()\n            result['execution_time'] = round(execution_time, 3)\n            result['timestamp'] = datetime.now().isoformat()\n\n            # Ajouter le type de requ\u00eate au r\u00e9sultat\n            result['type'] = query_type\n\n            # Mettre \u00e0 jour les statistiques\n            self.stats['queries_executed'] += 1\n\n            # Mettre en cache les requ\u00eates SELECT r\u00e9ussies\n            if (use_cache and query_hash and \n                result.get('success') and \n                query_type == 'select'):\n\n                # Limiter la taille du cache\n                if len(self.query_cache) &gt;= self.config['max_query_cache']:\n                    # Supprimer la plus ancienne entr\u00e9e\n                    oldest_key = min(self.query_cache.keys(), \n                                    key=lambda k: self.query_cache[k]['timestamp'])\n                    del self.query_cache[oldest_key]\n\n                self.query_cache[query_hash] = result\n\n            # Logger les requ\u00eates importantes\n            if execution_time &gt; 1.0:  # Plus d'1 seconde\n                logger.warning(f\"Slow query ({execution_time:.2f}s): {sql[:100]}...\")\n\n            return result\n\n    except SQLExecutionError as e:\n        self.stats['errors'] += 1\n        logger.error(f\"Query execution error: {e}\")\n\n        # Tentative de r\u00e9cup\u00e9ration pour certaines erreurs\n        if \"database is locked\" in str(e) and self.config['auto_recovery']:\n            logger.info(\"Database locked, attempting recovery...\")\n            self._auto_recover()\n\n            # R\u00e9essayer la requ\u00eate\n            return self.execute(sql, params, use_cache=False)\n\n        raise\n\n    except Exception as e:\n        self.stats['errors'] += 1\n        logger.error(f\"Unexpected error: {e}\")\n        raise SQLExecutionError(f\"Database error: {str(e)}\")\n</code></pre>"},{"location":"api/database/#gsql.database.Database.insert","title":"<code>insert(table_name, values, returning=None)</code>","text":"<p>Ins\u00e8re une ligne dans une table</p> Source code in <code>gsql/database.py</code> <pre><code>def insert(self, table_name: str, values: Dict, \n           returning: str = None) -&gt; Dict:\n    \"\"\"Ins\u00e8re une ligne dans une table\"\"\"\n    try:\n        # Construire la requ\u00eate INSERT\n        columns = ', '.join(values.keys())\n        placeholders = ', '.join(['?' for _ in values])\n\n        sql = f\"INSERT INTO {table_name} ({columns}) VALUES ({placeholders})\"\n\n        if returning:\n            sql += f\" RETURNING {returning}\"\n\n        # Ex\u00e9cuter avec les valeurs\n        result = self.execute(sql, tuple(values.values()))\n\n        return {\n            'type': 'insert',\n            'table': table_name,\n            'lastrowid': result.get('lastrowid'),\n            'rows_affected': result.get('rows_affected', 0),\n            'message': f'Row inserted into {table_name}',\n            'success': True\n        }\n\n    except Exception as e:\n        raise SQLExecutionError(f\"Failed to insert into {table_name}: {e}\")\n</code></pre>"},{"location":"api/database/#gsql.database.Database.optimize","title":"<code>optimize()</code>","text":"<p>Optimise la base de donn\u00e9es</p> Source code in <code>gsql/database.py</code> <pre><code>def optimize(self) -&gt; Dict:\n    \"\"\"Optimise la base de donn\u00e9es\"\"\"\n    try:\n        # Ex\u00e9cuter plusieurs optimisations\n        results = []\n\n        # 1. VACUUM\n        vacuum_result = self._execute_vacuum()\n        results.append(('vacuum', vacuum_result['success']))\n\n        # 2. ANALYZE pour les statistiques\n        analyze_result = self.execute(\"ANALYZE\")\n        results.append(('analyze', analyze_result.get('success', False)))\n\n        # 3. Nettoyer le cache\n        self.query_cache.clear()\n        results.append(('clear_cache', True))\n\n        # 4. Nettoyer le buffer pool\n        self.storage.buffer_pool.invalidate()\n        results.append(('clear_buffer_pool', True))\n\n        return {\n            'type': 'optimize',\n            'operations': results,\n            'message': 'Database optimization completed',\n            'success': all(r[1] for r in results)\n        }\n\n    except Exception as e:\n        return {\n            'type': 'optimize',\n            'message': f'Error during optimization: {e}',\n            'success': False\n        }\n</code></pre>"},{"location":"api/database/#gsql.database.Database.register_function","title":"<code>register_function(name, func, num_params=-1)</code>","text":"<p>Enregistre une fonction Python dans la base</p> Source code in <code>gsql/database.py</code> <pre><code>def register_function(self, name: str, func, num_params: int = -1) -&gt; Dict:\n    \"\"\"Enregistre une fonction Python dans la base\"\"\"\n    try:\n        self.storage.register_function(name, func, num_params)\n\n        return {\n            'type': 'register_function',\n            'name': name,\n            'num_params': num_params,\n            'message': f'Function {name} registered',\n            'success': True\n        }\n\n    except Exception as e:\n        raise FunctionError(f\"Failed to register function {name}: {e}\")\n</code></pre>"},{"location":"api/database/#gsql.database.Database.rollback_transaction","title":"<code>rollback_transaction(tid, to_savepoint=None)</code>","text":"<p>Annule une transaction</p> Source code in <code>gsql/database.py</code> <pre><code>def rollback_transaction(self, tid: int, to_savepoint: str = None) -&gt; Dict:\n    \"\"\"Annule une transaction\"\"\"\n    try:\n        success = self.storage.rollback_transaction(tid, to_savepoint)\n\n        if not to_savepoint and tid in self.active_transactions:\n            del self.active_transactions[tid]\n\n        return {\n            'type': 'transaction',\n            'tid': tid,\n            'message': f'Transaction {tid} rolled back' + \n                      (f' to {to_savepoint}' if to_savepoint else ''),\n            'success': success\n        }\n\n    except Exception as e:\n        raise TransactionError(f\"Failed to rollback transaction {tid}: {e}\")\n</code></pre>"},{"location":"api/database/#gsql.database.Database.select","title":"<code>select(table_name, columns=None, where=None, limit=None, offset=0, order_by=None)</code>","text":"<p>Ex\u00e9cute une requ\u00eate SELECT avec param\u00e8tres simplifi\u00e9s</p> Source code in <code>gsql/database.py</code> <pre><code>def select(self, table_name: str, columns: List[str] = None, \n           where: Dict = None, limit: int = None, \n           offset: int = 0, order_by: str = None) -&gt; Dict:\n    \"\"\"Ex\u00e9cute une requ\u00eate SELECT avec param\u00e8tres simplifi\u00e9s\"\"\"\n    try:\n        # Construire la requ\u00eate SELECT\n        cols = ', '.join(columns) if columns else '*'\n        sql = f\"SELECT {cols} FROM {table_name}\"\n\n        # Ajouter WHERE\n        params = []\n        if where:\n            conditions = []\n            for col, val in where.items():\n                if isinstance(val, (list, tuple)):\n                    placeholders = ', '.join(['?' for _ in val])\n                    conditions.append(f\"{col} IN ({placeholders})\")\n                    params.extend(val)\n                else:\n                    conditions.append(f\"{col} = ?\")\n                    params.append(val)\n\n            if conditions:\n                sql += f\" WHERE {' AND '.join(conditions)}\"\n\n        # Ajouter ORDER BY\n        if order_by:\n            sql += f\" ORDER BY {order_by}\"\n\n        # Ajouter LIMIT et OFFSET\n        if limit is not None:\n            sql += f\" LIMIT {limit}\"\n            if offset:\n                sql += f\" OFFSET {offset}\"\n\n        # Ex\u00e9cuter la requ\u00eate\n        result = self.execute(sql, params if params else None)\n\n        return result\n\n    except Exception as e:\n        raise SQLExecutionError(f\"Failed to select from {table_name}: {e}\")\n</code></pre>"},{"location":"api/database/#gsql.database.connect","title":"<code>connect(db_path, **kwargs)</code>","text":"<p>Connecte \u00e0 une base de donn\u00e9es GSQL (alias pour create_database)</p> Source code in <code>gsql/database.py</code> <pre><code>def connect(db_path: str, **kwargs) -&gt; Database:\n    \"\"\"Connecte \u00e0 une base de donn\u00e9es GSQL (alias pour create_database)\"\"\"\n    return create_database(db_path, **kwargs)\n</code></pre>"},{"location":"api/database/#gsql.database.create_database","title":"<code>create_database(db_path=None, **kwargs)</code>","text":"<p>Cr\u00e9e une nouvelle instance de base de donn\u00e9es Accepte 'path' comme alias pour 'db_path' pour la compatibilit\u00e9</p> Source code in <code>gsql/database.py</code> <pre><code>def create_database(db_path=None, **kwargs) -&gt; Database:\n    \"\"\"\n    Cr\u00e9e une nouvelle instance de base de donn\u00e9es\n    Accepte 'path' comme alias pour 'db_path' pour la compatibilit\u00e9\n    \"\"\"\n    # Si 'path' est fourni dans kwargs, l'utiliser comme db_path\n    if 'path' in kwargs:\n        db_path = kwargs.pop('path')\n\n    return Database(db_path, **kwargs)\n</code></pre>"},{"location":"api/database/#gsql.database.get_default_database","title":"<code>get_default_database()</code>","text":"<p>R\u00e9cup\u00e8re l'instance de base de donn\u00e9es par d\u00e9faut</p> Source code in <code>gsql/database.py</code> <pre><code>def get_default_database() -&gt; Optional[Database]:\n    \"\"\"R\u00e9cup\u00e8re l'instance de base de donn\u00e9es par d\u00e9faut\"\"\"\n    # Cette fonction peut g\u00e9rer une instance globale\n    if not hasattr(get_default_database, '_instance'):\n        get_default_database._instance = None\n\n    return get_default_database._instance\n</code></pre>"},{"location":"api/database/#gsql.database.set_default_database","title":"<code>set_default_database(db)</code>","text":"<p>D\u00e9finit l'instance de base de donn\u00e9es par d\u00e9faut</p> Source code in <code>gsql/database.py</code> <pre><code>def set_default_database(db: Database):\n    \"\"\"D\u00e9finit l'instance de base de donn\u00e9es par d\u00e9faut\"\"\"\n    get_default_database._instance = db\n</code></pre>"},{"location":"api/database/#reference-des-fonctions_1","title":"R\u00e9f\u00e9rence des fonctions","text":"<p>GSQL Database Module - SQLite Backend Only Version: 3.0 - Auto-recovery, no YAML</p>"},{"location":"api/database/#gsql.database.Database","title":"<code>Database</code>","text":"<p>Base de donn\u00e9es SQLite auto-r\u00e9cup\u00e9rante</p> Source code in <code>gsql/database.py</code> <pre><code>class Database:\n    \"\"\"Base de donn\u00e9es SQLite auto-r\u00e9cup\u00e9rante\"\"\"\n\n    def __init__(self, db_path=None, base_dir=\"/root/.gsql\", \n                 buffer_pool_size=100, enable_wal=True, auto_recovery=True):\n        \"\"\"\n        Initialise la base de donn\u00e9es SQLite\n\n        Args:\n            db_path: Chemin de la base (None pour auto)\n            base_dir: R\u00e9pertoire de base pour GSQL\n            buffer_pool_size: Taille du buffer pool\n            enable_wal: Activer le mode WAL\n            auto_recovery: Activer la r\u00e9cup\u00e9ration automatique\n        \"\"\"\n        self.base_dir = Path(base_dir)\n        self.base_dir.mkdir(parents=True, exist_ok=True)\n\n        # Configuration\n        self.config = {\n            'db_path': db_path,\n            'base_dir': str(base_dir),\n            'buffer_pool_size': buffer_pool_size,\n            'enable_wal': enable_wal,\n            'auto_recovery': auto_recovery,\n            'auto_backup': True,\n            'backup_interval': 24 * 3600,  # 24 heures\n            'max_query_cache': 100,\n            'query_timeout': 30,  # secondes\n            'version': '3.0'\n        }\n\n        # Initialiser le moteur de stockage\n        self.storage = create_storage(\n            db_path=db_path,\n            base_dir=base_dir,\n            buffer_pool_size=buffer_pool_size,\n            enable_wal=enable_wal\n        )\n\n        # \u00c9tat de la base\n        self.is_open = True\n        self.initialized = False\n        self.lock = threading.RLock()\n\n        # Cache des r\u00e9sultats\n        self.query_cache = {}\n        self.schema_cache = {}\n\n        # Statistiques\n        self.stats = {\n            'queries_executed': 0,\n            'queries_cached': 0,\n            'transactions': 0,\n            'errors': 0,\n            'start_time': datetime.now(),\n            'last_backup': None\n        }\n\n        # Journal de transaction actif\n        self.active_transactions = {}\n\n        # Initialiser les tables syst\u00e8me\n        self._initialize_database()\n\n        logger.info(f\"GSQL Database initialized (v{self.config['version']})\")\n\n    def _save_config(self):\n        \"\"\"Sauvegarde la configuration dans un fichier JSON\"\"\"\n        config_file = self.base_dir / \"gsql_config.json\"\n        try:\n            with open(config_file, 'w') as f:\n                json.dump(self.config, f, indent=2)\n        except Exception as e:\n            logger.warning(f\"Failed to save config: {e}\")\n\n    def _initialize_database(self, skip_recovery=False):\n        \"\"\"Initialise les tables et structures syst\u00e8me\"\"\"\n        try:\n            with self.lock:\n                # V\u00e9rifier si les tables syst\u00e8me existent\n                tables = self.storage.get_tables()\n\n                # Cr\u00e9er des tables par d\u00e9faut si n\u00e9cessaire\n                default_tables = self._get_default_tables()\n\n                for table_name, table_sql in default_tables.items():\n                    table_exists = any(t['table_name'] == table_name for t in tables)\n\n                    if not table_exists:\n                        logger.info(f\"Creating default table: {table_name}\")\n                        self.storage.execute(table_sql)\n\n                self.initialized = True\n\n                # Sauvegarder la configuration\n                self._save_config()\n\n        except Exception as e:\n            logger.error(f\"Failed to initialize database: {e}\")\n            if self.config['auto_recovery'] and not skip_recovery:\n                logger.warning(\"Attempting auto-recovery...\")\n                self._auto_recover()\n            else:\n                raise\n\n    def _get_default_tables(self) -&gt; Dict[str, str]:\n        \"\"\"Retourne les tables par d\u00e9faut \u00e0 cr\u00e9er\"\"\"\n        return {\n            'users': \"\"\"\n                CREATE TABLE IF NOT EXISTS users (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    username TEXT UNIQUE NOT NULL,\n                    email TEXT UNIQUE NOT NULL,\n                    full_name TEXT,\n                    age INTEGER CHECK(age &gt;= 0),\n                    city TEXT DEFAULT 'Unknown',\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n                )\n            \"\"\",\n\n            'products': \"\"\"\n                CREATE TABLE IF NOT EXISTS products (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    name TEXT NOT NULL,\n                    description TEXT,\n                    price REAL NOT NULL CHECK(price &gt;= 0),\n                    category TEXT,\n                    stock INTEGER DEFAULT 0 CHECK(stock &gt;= 0),\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                    active BOOLEAN DEFAULT 1\n                )\n            \"\"\",\n\n            'orders': \"\"\"\n                CREATE TABLE IF NOT EXISTS orders (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    user_id INTEGER NOT NULL,\n                    product_id INTEGER NOT NULL,\n                    quantity INTEGER NOT NULL CHECK(quantity &gt; 0),\n                    total_price REAL NOT NULL CHECK(total_price &gt;= 0),\n                    status TEXT DEFAULT 'pending',\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,\n                    FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE CASCADE\n                )\n            \"\"\",\n\n            'logs': \"\"\"\n                CREATE TABLE IF NOT EXISTS logs (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    level TEXT NOT NULL,\n                    message TEXT NOT NULL,\n                    source TEXT,\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n                )\n            \"\"\"\n        }\n\n    def _auto_recover(self, recursion_depth=0):\n        \"\"\"Tente une r\u00e9cup\u00e9ration automatique avec limite de r\u00e9cursion\"\"\"\n        MAX_RECURSION = 3\n\n        if recursion_depth &gt;= MAX_RECURSION:\n            logger.error(f\"Max recursion depth ({MAX_RECURSION}) reached in auto-recovery\")\n            raise SQLExecutionError(\"Auto-recovery failed: max recursion depth exceeded\")\n\n        try:\n            logger.warning(f\"Starting auto-recovery (attempt {recursion_depth + 1})...\")\n\n            # Fermer et r\u00e9ouvrir le storage\n            if self.storage:\n                self.storage.close()\n\n            # R\u00e9initialiser le storage\n            self.storage = create_storage(\n                db_path=self.config['db_path'],\n                base_dir=self.config['base_dir'],\n                buffer_pool_size=self.config['buffer_pool_size'],\n                enable_wal=self.config['enable_wal']\n            )\n\n            # R\u00e9initialiser les tables SANS d\u00e9clencher une nouvelle r\u00e9cup\u00e9ration\n            self._initialize_database(skip_recovery=True)\n\n            logger.info(\"Auto-recovery completed successfully\")\n\n        except Exception as e:\n            logger.error(f\"Auto-recovery attempt {recursion_depth + 1} failed: {e}\")\n\n            # R\u00e9essayer si pas encore \u00e0 la limite\n            if recursion_depth &lt; MAX_RECURSION - 1:\n                wait_time = 1 * (2 ** recursion_depth)\n                time.sleep(wait_time)\n                return self._auto_recover(recursion_depth + 1)\n            else:\n                raise SQLExecutionError(f\"Database recovery failed after {MAX_RECURSION} attempts: {e}\")\n\n    def execute(self, sql: str, params: Dict = None,\n                use_cache: bool = True, timeout: int = None) -&gt; Dict:\n        \"\"\"\n        Ex\u00e9cute une requ\u00eate SQL sur la base de donn\u00e9es\n\n        Args:\n            sql: Requ\u00eate SQL \u00e0 ex\u00e9cuter\n            params: Param\u00e8tres pour la requ\u00eate pr\u00e9par\u00e9e\n            use_cache: Utiliser le cache de requ\u00eates\n            timeout: Timeout en secondes\n\n        Returns:\n            Dict: R\u00e9sultats format\u00e9s de la requ\u00eate\n        \"\"\"\n        if not self.is_open:\n            raise SQLExecutionError(\"Database is closed\")\n\n        # D\u00e9tecter les commandes sp\u00e9ciales GSQL\n        special_result = self._handle_special_commands(sql)\n        if special_result:\n            return special_result\n\n        # D\u00e9tecter les commandes sp\u00e9ciales GSQL\n        special_result = self._handle_special_commands(sql)\n        if special_result:\n            return special_result\n        start_time = datetime.now()\n        query_hash = None\n\n        # G\u00e9n\u00e9rer un hash pour le cache\n        if use_cache and params is None:\n            query_hash = hashlib.md5(sql.encode()).hexdigest()[:16]\n            cached = self.query_cache.get(query_hash)\n            if cached:\n                self.stats['queries_cached'] += 1\n                logger.debug(f\"Query cache hit: {query_hash}\")\n                return cached\n\n        try:\n            with self.lock:\n                # D\u00e9terminer le type de requ\u00eate bas\u00e9 sur le SQL\n                sql_upper = sql.upper().strip()\n                if sql_upper.startswith('SELECT'):\n                    query_type = 'select'\n                elif sql_upper.startswith('INSERT'):\n                    query_type = 'insert'\n                elif sql_upper.startswith('UPDATE'):\n                    query_type = 'update'\n                elif sql_upper.startswith('DELETE'):\n                    query_type = 'delete'\n                elif sql_upper.startswith('CREATE'):\n                    query_type = 'create'\n                elif sql_upper.startswith('DROP'):\n                    query_type = 'drop'\n                elif sql_upper.startswith('ALTER'):\n                    query_type = 'alter'\n                elif sql_upper.startswith('BEGIN'):\n                    query_type = 'begin'\n                elif sql_upper.startswith('COMMIT'):\n                    query_type = 'commit'\n                elif sql_upper.startswith('ROLLBACK'):\n                    query_type = 'rollback'\n                else:\n                    query_type = 'unknown'\n\n                # Ex\u00e9cuter la requ\u00eate via le storage\n                result = self.storage.execute(sql, params)\n\n                # Ajouter des m\u00e9tadonn\u00e9es\n                execution_time = (datetime.now() - start_time).total_seconds()\n                result['execution_time'] = round(execution_time, 3)\n                result['timestamp'] = datetime.now().isoformat()\n\n                # Ajouter le type de requ\u00eate au r\u00e9sultat\n                result['type'] = query_type\n\n                # Mettre \u00e0 jour les statistiques\n                self.stats['queries_executed'] += 1\n\n                # Mettre en cache les requ\u00eates SELECT r\u00e9ussies\n                if (use_cache and query_hash and \n                    result.get('success') and \n                    query_type == 'select'):\n\n                    # Limiter la taille du cache\n                    if len(self.query_cache) &gt;= self.config['max_query_cache']:\n                        # Supprimer la plus ancienne entr\u00e9e\n                        oldest_key = min(self.query_cache.keys(), \n                                        key=lambda k: self.query_cache[k]['timestamp'])\n                        del self.query_cache[oldest_key]\n\n                    self.query_cache[query_hash] = result\n\n                # Logger les requ\u00eates importantes\n                if execution_time &gt; 1.0:  # Plus d'1 seconde\n                    logger.warning(f\"Slow query ({execution_time:.2f}s): {sql[:100]}...\")\n\n                return result\n\n        except SQLExecutionError as e:\n            self.stats['errors'] += 1\n            logger.error(f\"Query execution error: {e}\")\n\n            # Tentative de r\u00e9cup\u00e9ration pour certaines erreurs\n            if \"database is locked\" in str(e) and self.config['auto_recovery']:\n                logger.info(\"Database locked, attempting recovery...\")\n                self._auto_recover()\n\n                # R\u00e9essayer la requ\u00eate\n                return self.execute(sql, params, use_cache=False)\n\n            raise\n\n        except Exception as e:\n            self.stats['errors'] += 1\n            logger.error(f\"Unexpected error: {e}\")\n            raise SQLExecutionError(f\"Database error: {str(e)}\")\n\n    def _handle_special_commands(self, sql: str) -&gt; Optional[Dict]:\n        logger.debug(f\"Checking special command: {sql}\")\n        \"\"\"G\u00e8re les commandes sp\u00e9ciales GSQL\"\"\"\n        sql_upper = sql.strip().upper()\n\n        # SHOW TABLES\n        if sql_upper == \"SHOW TABLES\" or sql == \".tables\":\n            return self._execute_show_tables()\n\n        # SHOW FUNCTIONS\n        elif sql_upper == \"SHOW FUNCTIONS\":\n            return self._execute_show_functions()\n\n        # DESCRIBE / SCHEMA\n        elif sql_upper.startswith(\"DESCRIBE \") or sql_upper.startswith(\"SCHEMA \"):\n            table_name = sql.split()[1] if len(sql.split()) &gt; 1 else None\n            if table_name:\n                return self._execute_describe_table(table_name)\n\n        # STATS\n        elif sql_upper == \"STATS\" or sql == \".stats\":\n            return self._execute_stats()\n\n        # VACUUM\n        elif sql_upper == \"VACUUM\":\n            return self._execute_vacuum()\n\n        # BACKUP\n        elif sql_upper.startswith(\"BACKUP\"):\n            return self._execute_backup(sql)\n\n        # HELP\n        elif sql_upper == \"HELP\" or sql == \".help\":\n            return self._execute_help()\n\n        return None\n\n    def _execute_show_tables(self) -&gt; Dict:\n        \"\"\"Ex\u00e9cute SHOW TABLES\"\"\"\n        try:\n            tables = self.storage.get_tables()\n\n            # Formater les r\u00e9sultats\n            formatted_tables = []\n            for table in tables:\n                formatted_tables.append({\n                    'table': table['table_name'],\n                    'rows': table.get('row_count', 0),\n                    'size_kb': round(table.get('size_bytes', 0) / 1024, 2),\n                    'columns': table.get('columns', []),\n                    'last_analyzed': table.get('last_analyzed')\n                })\n\n            return {\n                'type': 'show_tables',\n                'tables': formatted_tables,\n                'count': len(formatted_tables),\n                'message': f'Found {len(formatted_tables)} table(s)',\n                'success': True\n            }\n\n        except Exception as e:\n            return {\n                'type': 'show_tables',\n                'tables': [],\n                'count': 0,\n                'message': f'Error: {str(e)}',\n                'success': False\n            }\n\n    def _execute_show_functions(self) -&gt; Dict:\n        \"\"\"Ex\u00e9cute SHOW FUNCTIONS\"\"\"\n        try:\n            # R\u00e9cup\u00e9rer les fonctions depuis le storage\n            result = self.storage.execute(\"\"\"\n                SELECT name, params, returns, created_at, is_active\n                FROM _gsql_functions\n                WHERE is_active = 1\n                ORDER BY name\n            \"\"\")\n\n            # Ajouter les fonctions int\u00e9gr\u00e9es\n            builtin_funcs = [\n                {'name': 'UPPER(text)', 'type': 'builtin', 'description': 'Convert to uppercase'},\n                {'name': 'LOWER(text)', 'type': 'builtin', 'description': 'Convert to lowercase'},\n                {'name': 'LENGTH(text)', 'type': 'builtin', 'description': 'String length'},\n                {'name': 'ABS(number)', 'type': 'builtin', 'description': 'Absolute value'},\n                {'name': 'ROUND(number, decimals)', 'type': 'builtin', 'description': 'Round number'},\n                {'name': 'CONCAT(str1, str2, ...)', 'type': 'builtin', 'description': 'Concatenate strings'},\n                {'name': 'NOW()', 'type': 'builtin', 'description': 'Current timestamp'},\n                {'name': 'DATE()', 'type': 'builtin', 'description': 'Current date'}\n            ]\n\n            functions = []\n            if result['success'] and result['type'] == 'select':\n                for row in result['rows']:\n                    functions.append({\n                        'name': row['name'],\n                        'type': 'user',\n                        'params': json.loads(row['params']) if row['params'] else [],\n                        'returns': row['returns'],\n                        'created_at': row['created_at']\n                    })\n\n            functions.extend(builtin_funcs)\n\n            return {\n                'type': 'show_functions',\n                'functions': functions,\n                'count': len(functions),\n                'message': f'Found {len(functions)} function(s)',\n                'success': True\n            }\n\n        except Exception as e:\n            return {\n                'type': 'show_functions',\n                'functions': [],\n                'count': 0,\n                'message': f'Error: {str(e)}',\n                'success': False\n            }\n\n    def _execute_describe_table(self, table_name: str) -&gt; Dict:\n        \"\"\"Ex\u00e9cute DESCRIBE &lt;table&gt;\"\"\"\n        try:\n            schema = self.storage.get_table_schema(table_name)\n\n            if not schema:\n                raise SQLExecutionError(f\"Table '{table_name}' not found\")\n\n            # Formater le sch\u00e9ma\n            columns_info = []\n            for col_name, col_info in schema.get('columns', {}).items():\n                column_desc = f\"{col_name} {col_info.get('type', 'TEXT')}\"\n\n                if col_info.get('pk'):\n                    column_desc += \" PRIMARY KEY\"\n                if col_info.get('not_null'):\n                    column_desc += \" NOT NULL\"\n                if col_info.get('default'):\n                    column_desc += f\" DEFAULT {col_info['default']}\"\n\n                columns_info.append({\n                    'field': col_name,\n                    'type': col_info.get('type', 'TEXT'),\n                    'null': not col_info.get('not_null', False),\n                    'key': 'PRI' if col_info.get('pk') else '',\n                    'default': col_info.get('default'),\n                    'extra': 'auto_increment' if col_info.get('auto_increment') else ''\n                })\n\n            return {\n                'type': 'describe',\n                'table': table_name,\n                'columns': columns_info,\n                'indexes': schema.get('indexes', []),\n                'foreign_keys': schema.get('foreign_keys', []),\n                'count': len(columns_info),\n                'message': f'Table structure of {table_name}',\n                'success': True\n            }\n\n        except Exception as e:\n            return {\n                'type': 'describe',\n                'table': table_name,\n                'columns': [],\n                'message': f'Error: {str(e)}',\n                'success': False\n            }\n\n    def _execute_stats(self) -&gt; Dict:\n        \"\"\"Ex\u00e9cute STATS pour voir les statistiques\"\"\"\n        try:\n            # R\u00e9cup\u00e9rer les statistiques du storage\n            storage_stats = self.storage.get_stats()\n\n            # Statistiques de la base\n            db_stats = {\n                'queries_executed': self.stats['queries_executed'],\n                'queries_cached': self.stats['queries_cached'],\n                'cache_hit_ratio': (\n                    self.stats['queries_cached'] / self.stats['queries_executed'] \n                    if self.stats['queries_executed'] &gt; 0 else 0\n                ),\n                'errors': self.stats['errors'],\n                'uptime_seconds': (datetime.now() - self.stats['start_time']).total_seconds(),\n                'query_cache_size': len(self.query_cache),\n                'active_transactions': len(self.active_transactions)\n            }\n\n            return {\n                'type': 'stats',\n                'database': db_stats,\n                'storage': storage_stats,\n                'config': self.config,\n                'message': 'Database statistics',\n                'success': True\n            }\n\n        except Exception as e:\n            return {\n                'type': 'stats',\n                'message': f'Error: {str(e)}',\n                'success': False\n            }\n\n    def _execute_vacuum(self) -&gt; Dict:\n        \"\"\"Ex\u00e9cute VACUUM pour optimiser la base\"\"\"\n        try:\n            success = self.storage.vacuum()\n\n            return {\n                'type': 'vacuum',\n                'success': success,\n                'message': 'Database optimization completed' if success else 'Optimization failed'\n            }\n\n        except Exception as e:\n            return {\n                'type': 'vacuum',\n                'success': False,\n                'message': f'Error: {str(e)}'\n            }\n\n    def _execute_backup(self, sql: str) -&gt; Dict:\n        \"\"\"Ex\u00e9cute BACKUP [path]\"\"\"\n        try:\n            # Extraire le chemin optionnel\n            parts = sql.split()\n            backup_path = parts[1] if len(parts) &gt; 1 else None\n\n            # Cr\u00e9er la sauvegarde\n            backup_file = self.storage.backup(backup_path)\n\n            # Mettre \u00e0 jour les statistiques\n            self.stats['last_backup'] = datetime.now().isoformat()\n\n            return {\n                'type': 'backup',\n                'success': True,\n                'backup_file': backup_file,\n                'message': f'Backup created: {backup_file}'\n            }\n\n        except Exception as e:\n            return {\n                'type': 'backup',\n                'success': False,\n                'message': f'Error: {str(e)}'\n            }\n\n    def _execute_help(self) -&gt; Dict:\n        \"\"\"Ex\u00e9cute HELP pour afficher l'aide\"\"\"\n        help_text = \"\"\"\nGSQL Database Commands:\n\nDATA MANIPULATION:\n  SELECT * FROM table [WHERE condition] [LIMIT n]\n  INSERT INTO table (col1, col2) VALUES (val1, val2)\n  UPDATE table SET col=value [WHERE condition]\n  DELETE FROM table [WHERE condition]\n\nDATA DEFINITION:\n  CREATE TABLE name (col1 TYPE, col2 TYPE, ...)\n  DROP TABLE name\n  ALTER TABLE name ADD COLUMN col TYPE\n  CREATE INDEX idx_name ON table(column)\n\nDATABASE MANAGEMENT:\n  SHOW TABLES                    - List all tables\n  DESCRIBE table                 - Show table structure\n  SHOW FUNCTIONS                 - List all functions\n  STATS                          - Show database statistics\n  VACUUM                         - Optimize database\n  BACKUP [path]                  - Create database backup\n  HELP                           - This help message\n\nTRANSACTIONS:\n  BEGIN [DEFERRED|IMMEDIATE|EXCLUSIVE]\n  COMMIT\n  ROLLBACK [TO SAVEPOINT name]\n  SAVEPOINT name\n\nDOT COMMANDS (compatible SQLite):\n  .tables                        - List tables\n  .schema [table]                - Show schema\n  .stats                         - Show stats\n  .help                          - Show help\n  .backup [file]                 - Create backup\n  .vacuum                        - Optimize database\n\"\"\"\n\n        return {\n            'type': 'help',\n            'message': help_text,\n            'success': True\n        }\n\n    # ==================== TRANSACTION MANAGEMENT ====================\n\n    def begin_transaction(self, isolation_level: str = \"DEFERRED\") -&gt; Dict:\n        \"\"\"D\u00e9marre une nouvelle transaction\"\"\"\n        try:\n            tid = self.storage.begin_transaction(isolation_level)\n\n            # Enregistrer la transaction\n            self.active_transactions[tid] = {\n                'start_time': datetime.now(),\n                'isolation': isolation_level,\n                'queries': []\n            }\n\n            self.stats['transactions'] += 1\n\n            return {\n                'type': 'transaction',\n                'tid': tid,\n                'isolation': isolation_level,\n                'message': f'Transaction {tid} started',\n                'success': True\n            }\n\n        except Exception as e:\n            raise TransactionError(f\"Failed to begin transaction: {e}\")\n\n    def commit_transaction(self, tid: int) -&gt; Dict:\n        \"\"\"Valide une transaction\"\"\"\n        try:\n            success = self.storage.commit_transaction(tid)\n\n            if tid in self.active_transactions:\n                del self.active_transactions[tid]\n\n            return {\n                'type': 'transaction',\n                'tid': tid,\n                'message': f'Transaction {tid} committed',\n                'success': success\n            }\n\n        except Exception as e:\n            raise TransactionError(f\"Failed to commit transaction {tid}: {e}\")\n\n    def rollback_transaction(self, tid: int, to_savepoint: str = None) -&gt; Dict:\n        \"\"\"Annule une transaction\"\"\"\n        try:\n            success = self.storage.rollback_transaction(tid, to_savepoint)\n\n            if not to_savepoint and tid in self.active_transactions:\n                del self.active_transactions[tid]\n\n            return {\n                'type': 'transaction',\n                'tid': tid,\n                'message': f'Transaction {tid} rolled back' + \n                          (f' to {to_savepoint}' if to_savepoint else ''),\n                'success': success\n            }\n\n        except Exception as e:\n            raise TransactionError(f\"Failed to rollback transaction {tid}: {e}\")\n\n    def create_savepoint(self, tid: int, name: str) -&gt; Dict:\n        \"\"\"Cr\u00e9e un savepoint dans une transaction\"\"\"\n        try:\n            success = self.storage.savepoint(tid, name)\n\n            if tid in self.active_transactions:\n                self.active_transactions[tid]['savepoints'] = \\\n                    self.active_transactions[tid].get('savepoints', []) + [name]\n\n            return {\n                'type': 'savepoint',\n                'tid': tid,\n                'name': name,\n                'message': f'Savepoint {name} created in transaction {tid}',\n                'success': success\n            }\n\n        except Exception as e:\n            raise TransactionError(f\"Failed to create savepoint: {e}\")\n\n    # ==================== TABLE MANAGEMENT ====================\n\n    def create_table(self, table_name: str, columns: Dict) -&gt; Dict:\n        \"\"\"Cr\u00e9e une nouvelle table avec validation\"\"\"\n        try:\n            # Valider le nom de la table\n            if not re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', table_name):\n                raise SQLSyntaxError(f\"Invalid table name: '{table_name}'\")\n\n            # Construire la requ\u00eate SQL\n            column_defs = []\n            for col_name, col_spec in columns.items():\n                if isinstance(col_spec, str):\n                    col_def = f\"{col_name} {col_spec}\"\n                elif isinstance(col_spec, dict):\n                    col_def = f\"{col_name} {col_spec.get('type', 'TEXT')}\"\n\n                    if col_spec.get('primary_key'):\n                        col_def += \" PRIMARY KEY\"\n                    if col_spec.get('auto_increment'):\n                        col_def += \" AUTOINCREMENT\"\n                    if col_spec.get('not_null'):\n                        col_def += \" NOT NULL\"\n                    if 'default' in col_spec:\n                        default_val = col_spec['default']\n                        if isinstance(default_val, str) and not default_val.upper() in ['CURRENT_TIMESTAMP', 'NULL']:\n                            default_val = f\"'{default_val}'\"\n                        col_def += f\" DEFAULT {default_val}\"\n                    if col_spec.get('unique'):\n                        col_def += \" UNIQUE\"\n                    if 'check' in col_spec:\n                        col_def += f\" CHECK({col_spec['check']})\"\n                else:\n                    raise SQLSyntaxError(f\"Invalid column specification for '{col_name}'\")\n\n                column_defs.append(col_def)\n\n            sql = f\"CREATE TABLE {table_name} ({', '.join(column_defs)})\"\n\n            # Ex\u00e9cuter la cr\u00e9ation\n            result = self.execute(sql)\n\n            # Mettre \u00e0 jour le cache de sch\u00e9ma\n            self.storage._cache_table_schema(table_name)\n\n            return {\n                'type': 'create_table',\n                'table': table_name,\n                'columns': list(columns.keys()),\n                'sql': sql,\n                'message': f'Table {table_name} created successfully',\n                'success': True\n            }\n\n        except Exception as e:\n            raise SQLExecutionError(f\"Failed to create table {table_name}: {e}\")\n\n    def drop_table(self, table_name: str, if_exists: bool = True) -&gt; Dict:\n        \"\"\"Supprime une table\"\"\"\n        try:\n            sql = f\"DROP TABLE {'IF EXISTS ' if if_exists else ''}{table_name}\"\n            result = self.execute(sql)\n\n            # Nettoyer le cache\n            if table_name in self.schema_cache:\n                del self.schema_cache[table_name]\n\n            return {\n                'type': 'drop_table',\n                'table': table_name,\n                'message': f'Table {table_name} dropped',\n                'success': True\n            }\n\n        except Exception as e:\n            raise SQLExecutionError(f\"Failed to drop table {table_name}: {e}\")\n\n    def insert(self, table_name: str, values: Dict, \n               returning: str = None) -&gt; Dict:\n        \"\"\"Ins\u00e8re une ligne dans une table\"\"\"\n        try:\n            # Construire la requ\u00eate INSERT\n            columns = ', '.join(values.keys())\n            placeholders = ', '.join(['?' for _ in values])\n\n            sql = f\"INSERT INTO {table_name} ({columns}) VALUES ({placeholders})\"\n\n            if returning:\n                sql += f\" RETURNING {returning}\"\n\n            # Ex\u00e9cuter avec les valeurs\n            result = self.execute(sql, tuple(values.values()))\n\n            return {\n                'type': 'insert',\n                'table': table_name,\n                'lastrowid': result.get('lastrowid'),\n                'rows_affected': result.get('rows_affected', 0),\n                'message': f'Row inserted into {table_name}',\n                'success': True\n            }\n\n        except Exception as e:\n            raise SQLExecutionError(f\"Failed to insert into {table_name}: {e}\")\n\n    def select(self, table_name: str, columns: List[str] = None, \n               where: Dict = None, limit: int = None, \n               offset: int = 0, order_by: str = None) -&gt; Dict:\n        \"\"\"Ex\u00e9cute une requ\u00eate SELECT avec param\u00e8tres simplifi\u00e9s\"\"\"\n        try:\n            # Construire la requ\u00eate SELECT\n            cols = ', '.join(columns) if columns else '*'\n            sql = f\"SELECT {cols} FROM {table_name}\"\n\n            # Ajouter WHERE\n            params = []\n            if where:\n                conditions = []\n                for col, val in where.items():\n                    if isinstance(val, (list, tuple)):\n                        placeholders = ', '.join(['?' for _ in val])\n                        conditions.append(f\"{col} IN ({placeholders})\")\n                        params.extend(val)\n                    else:\n                        conditions.append(f\"{col} = ?\")\n                        params.append(val)\n\n                if conditions:\n                    sql += f\" WHERE {' AND '.join(conditions)}\"\n\n            # Ajouter ORDER BY\n            if order_by:\n                sql += f\" ORDER BY {order_by}\"\n\n            # Ajouter LIMIT et OFFSET\n            if limit is not None:\n                sql += f\" LIMIT {limit}\"\n                if offset:\n                    sql += f\" OFFSET {offset}\"\n\n            # Ex\u00e9cuter la requ\u00eate\n            result = self.execute(sql, params if params else None)\n\n            return result\n\n        except Exception as e:\n            raise SQLExecutionError(f\"Failed to select from {table_name}: {e}\")\n\n    # ==================== FUNCTION MANAGEMENT ====================\n\n    def register_function(self, name: str, func, num_params: int = -1) -&gt; Dict:\n        \"\"\"Enregistre une fonction Python dans la base\"\"\"\n        try:\n            self.storage.register_function(name, func, num_params)\n\n            return {\n                'type': 'register_function',\n                'name': name,\n                'num_params': num_params,\n                'message': f'Function {name} registered',\n                'success': True\n            }\n\n        except Exception as e:\n            raise FunctionError(f\"Failed to register function {name}: {e}\")\n\n    # ==================== MAINTENANCE ====================\n\n    def optimize(self) -&gt; Dict:\n        \"\"\"Optimise la base de donn\u00e9es\"\"\"\n        try:\n            # Ex\u00e9cuter plusieurs optimisations\n            results = []\n\n            # 1. VACUUM\n            vacuum_result = self._execute_vacuum()\n            results.append(('vacuum', vacuum_result['success']))\n\n            # 2. ANALYZE pour les statistiques\n            analyze_result = self.execute(\"ANALYZE\")\n            results.append(('analyze', analyze_result.get('success', False)))\n\n            # 3. Nettoyer le cache\n            self.query_cache.clear()\n            results.append(('clear_cache', True))\n\n            # 4. Nettoyer le buffer pool\n            self.storage.buffer_pool.invalidate()\n            results.append(('clear_buffer_pool', True))\n\n            return {\n                'type': 'optimize',\n                'operations': results,\n                'message': 'Database optimization completed',\n                'success': all(r[1] for r in results)\n            }\n\n        except Exception as e:\n            return {\n                'type': 'optimize',\n                'message': f'Error during optimization: {e}',\n                'success': False\n            }\n\n    def check_health(self) -&gt; Dict:\n        \"\"\"V\u00e9rifie la sant\u00e9 de la base de donn\u00e9es\"\"\"\n        try:\n            health_checks = []\n\n            # 1. Connexion\n            health_checks.append(('connection', self.is_open and self.storage.is_connected))\n\n            # 2. Tables syst\u00e8me\n            sys_tables = ['_gsql_metadata', '_gsql_schemas', '_gsql_functions']\n            for table in sys_tables:\n                result = self.execute(f\"SELECT 1 FROM {table} LIMIT 1\")\n                health_checks.append((f'table_{table}', result.get('success', False)))\n\n            # 3. Buffer pool\n            bp_stats = self.storage.buffer_pool.get_stats()\n            health_checks.append(('buffer_pool', bp_stats['hit_ratio'] &gt; 0.5))\n\n            # 4. Espace disque (estimation)\n            import shutil\n            disk_usage = shutil.disk_usage(self.base_dir)\n            free_gb = disk_usage.free / (1024**3)\n            health_checks.append(('disk_space', free_gb &gt; 1))  # 1GB minimum\n\n            # Calculer le score de sant\u00e9\n            passed = sum(1 for _, status in health_checks if status)\n            total = len(health_checks)\n            health_score = (passed / total) * 100\n\n            status = 'HEALTHY' if health_score &gt;= 80 else 'DEGRADED' if health_score &gt;= 50 else 'CRITICAL'\n\n            return {\n                'type': 'health_check',\n                'status': status,\n                'score': round(health_score, 1),\n                'checks': health_checks,\n                'passed': passed,\n                'total': total,\n                'message': f'Health check: {status} ({health_score:.1f}%)',\n                'success': health_score &gt;= 50\n            }\n\n        except Exception as e:\n            return {\n                'type': 'health_check',\n                'status': 'ERROR',\n                'score': 0,\n                'message': f'Health check failed: {e}',\n                'success': False\n            }\n\n    def close(self):\n        \"\"\"Ferme la base de donn\u00e9es proprement\"\"\"\n        with self.lock:\n            if self.is_open:\n                try:\n                    # Sauvegarder les statistiques\n                    self._save_stats()\n\n                    # Fermer le storage\n                    self.storage.close()\n\n                    # Fermer les transactions actives\n                    for tid in list(self.active_transactions.keys()):\n                        try:\n                            self.rollback_transaction(tid)\n                        except:\n                            pass\n\n                    self.is_open = False\n                    self.initialized = False\n\n                    logger.info(\"Database closed\")\n\n                except Exception as e:\n                    logger.error(f\"Error closing database: {e}\")\n\n    def _save_stats(self):\n        \"\"\"Sauvegarde les statistiques d'utilisation\"\"\"\n        stats_file = self.base_dir / \"gsql_stats.json\"\n        try:\n            # Convertir datetime en cha\u00eene pour JSON\n            stats_data = {\n                'stats': {\n                    'queries_executed': self.stats['queries_executed'],\n                    'queries_cached': self.stats['queries_cached'],\n                    'transactions': self.stats['transactions'],\n                    'errors': self.stats['errors'],\n                    'start_time': self.stats['start_time'].isoformat() if hasattr(self.stats['start_time'], 'isoformat') else str(self.stats['start_time']),\n                    'last_backup': self.stats['last_backup']\n                },\n                'last_run': datetime.now().isoformat(),\n                'version': self.config['version']\n            }\n\n            with open(stats_file, 'w') as f:\n                json.dump(stats_data, f, indent=2, default=str)\n\n        except Exception as e:\n            logger.warning(f\"Failed to save stats: {e}\")\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.close()\n\n    def __del__(self):\n        try:\n            self.close()\n        except:\n            pass\n</code></pre>"},{"location":"api/database/#gsql.database.Database.__init__","title":"<code>__init__(db_path=None, base_dir='/root/.gsql', buffer_pool_size=100, enable_wal=True, auto_recovery=True)</code>","text":"<p>Initialise la base de donn\u00e9es SQLite</p> <p>Parameters:</p> Name Type Description Default <code>db_path</code> <p>Chemin de la base (None pour auto)</p> <code>None</code> <code>base_dir</code> <p>R\u00e9pertoire de base pour GSQL</p> <code>'/root/.gsql'</code> <code>buffer_pool_size</code> <p>Taille du buffer pool</p> <code>100</code> <code>enable_wal</code> <p>Activer le mode WAL</p> <code>True</code> <code>auto_recovery</code> <p>Activer la r\u00e9cup\u00e9ration automatique</p> <code>True</code> Source code in <code>gsql/database.py</code> <pre><code>def __init__(self, db_path=None, base_dir=\"/root/.gsql\", \n             buffer_pool_size=100, enable_wal=True, auto_recovery=True):\n    \"\"\"\n    Initialise la base de donn\u00e9es SQLite\n\n    Args:\n        db_path: Chemin de la base (None pour auto)\n        base_dir: R\u00e9pertoire de base pour GSQL\n        buffer_pool_size: Taille du buffer pool\n        enable_wal: Activer le mode WAL\n        auto_recovery: Activer la r\u00e9cup\u00e9ration automatique\n    \"\"\"\n    self.base_dir = Path(base_dir)\n    self.base_dir.mkdir(parents=True, exist_ok=True)\n\n    # Configuration\n    self.config = {\n        'db_path': db_path,\n        'base_dir': str(base_dir),\n        'buffer_pool_size': buffer_pool_size,\n        'enable_wal': enable_wal,\n        'auto_recovery': auto_recovery,\n        'auto_backup': True,\n        'backup_interval': 24 * 3600,  # 24 heures\n        'max_query_cache': 100,\n        'query_timeout': 30,  # secondes\n        'version': '3.0'\n    }\n\n    # Initialiser le moteur de stockage\n    self.storage = create_storage(\n        db_path=db_path,\n        base_dir=base_dir,\n        buffer_pool_size=buffer_pool_size,\n        enable_wal=enable_wal\n    )\n\n    # \u00c9tat de la base\n    self.is_open = True\n    self.initialized = False\n    self.lock = threading.RLock()\n\n    # Cache des r\u00e9sultats\n    self.query_cache = {}\n    self.schema_cache = {}\n\n    # Statistiques\n    self.stats = {\n        'queries_executed': 0,\n        'queries_cached': 0,\n        'transactions': 0,\n        'errors': 0,\n        'start_time': datetime.now(),\n        'last_backup': None\n    }\n\n    # Journal de transaction actif\n    self.active_transactions = {}\n\n    # Initialiser les tables syst\u00e8me\n    self._initialize_database()\n\n    logger.info(f\"GSQL Database initialized (v{self.config['version']})\")\n</code></pre>"},{"location":"api/database/#gsql.database.Database.begin_transaction","title":"<code>begin_transaction(isolation_level='DEFERRED')</code>","text":"<p>D\u00e9marre une nouvelle transaction</p> Source code in <code>gsql/database.py</code> <pre><code>def begin_transaction(self, isolation_level: str = \"DEFERRED\") -&gt; Dict:\n    \"\"\"D\u00e9marre une nouvelle transaction\"\"\"\n    try:\n        tid = self.storage.begin_transaction(isolation_level)\n\n        # Enregistrer la transaction\n        self.active_transactions[tid] = {\n            'start_time': datetime.now(),\n            'isolation': isolation_level,\n            'queries': []\n        }\n\n        self.stats['transactions'] += 1\n\n        return {\n            'type': 'transaction',\n            'tid': tid,\n            'isolation': isolation_level,\n            'message': f'Transaction {tid} started',\n            'success': True\n        }\n\n    except Exception as e:\n        raise TransactionError(f\"Failed to begin transaction: {e}\")\n</code></pre>"},{"location":"api/database/#gsql.database.Database.check_health","title":"<code>check_health()</code>","text":"<p>V\u00e9rifie la sant\u00e9 de la base de donn\u00e9es</p> Source code in <code>gsql/database.py</code> <pre><code>def check_health(self) -&gt; Dict:\n    \"\"\"V\u00e9rifie la sant\u00e9 de la base de donn\u00e9es\"\"\"\n    try:\n        health_checks = []\n\n        # 1. Connexion\n        health_checks.append(('connection', self.is_open and self.storage.is_connected))\n\n        # 2. Tables syst\u00e8me\n        sys_tables = ['_gsql_metadata', '_gsql_schemas', '_gsql_functions']\n        for table in sys_tables:\n            result = self.execute(f\"SELECT 1 FROM {table} LIMIT 1\")\n            health_checks.append((f'table_{table}', result.get('success', False)))\n\n        # 3. Buffer pool\n        bp_stats = self.storage.buffer_pool.get_stats()\n        health_checks.append(('buffer_pool', bp_stats['hit_ratio'] &gt; 0.5))\n\n        # 4. Espace disque (estimation)\n        import shutil\n        disk_usage = shutil.disk_usage(self.base_dir)\n        free_gb = disk_usage.free / (1024**3)\n        health_checks.append(('disk_space', free_gb &gt; 1))  # 1GB minimum\n\n        # Calculer le score de sant\u00e9\n        passed = sum(1 for _, status in health_checks if status)\n        total = len(health_checks)\n        health_score = (passed / total) * 100\n\n        status = 'HEALTHY' if health_score &gt;= 80 else 'DEGRADED' if health_score &gt;= 50 else 'CRITICAL'\n\n        return {\n            'type': 'health_check',\n            'status': status,\n            'score': round(health_score, 1),\n            'checks': health_checks,\n            'passed': passed,\n            'total': total,\n            'message': f'Health check: {status} ({health_score:.1f}%)',\n            'success': health_score &gt;= 50\n        }\n\n    except Exception as e:\n        return {\n            'type': 'health_check',\n            'status': 'ERROR',\n            'score': 0,\n            'message': f'Health check failed: {e}',\n            'success': False\n        }\n</code></pre>"},{"location":"api/database/#gsql.database.Database.close","title":"<code>close()</code>","text":"<p>Ferme la base de donn\u00e9es proprement</p> Source code in <code>gsql/database.py</code> <pre><code>def close(self):\n    \"\"\"Ferme la base de donn\u00e9es proprement\"\"\"\n    with self.lock:\n        if self.is_open:\n            try:\n                # Sauvegarder les statistiques\n                self._save_stats()\n\n                # Fermer le storage\n                self.storage.close()\n\n                # Fermer les transactions actives\n                for tid in list(self.active_transactions.keys()):\n                    try:\n                        self.rollback_transaction(tid)\n                    except:\n                        pass\n\n                self.is_open = False\n                self.initialized = False\n\n                logger.info(\"Database closed\")\n\n            except Exception as e:\n                logger.error(f\"Error closing database: {e}\")\n</code></pre>"},{"location":"api/database/#gsql.database.Database.commit_transaction","title":"<code>commit_transaction(tid)</code>","text":"<p>Valide une transaction</p> Source code in <code>gsql/database.py</code> <pre><code>def commit_transaction(self, tid: int) -&gt; Dict:\n    \"\"\"Valide une transaction\"\"\"\n    try:\n        success = self.storage.commit_transaction(tid)\n\n        if tid in self.active_transactions:\n            del self.active_transactions[tid]\n\n        return {\n            'type': 'transaction',\n            'tid': tid,\n            'message': f'Transaction {tid} committed',\n            'success': success\n        }\n\n    except Exception as e:\n        raise TransactionError(f\"Failed to commit transaction {tid}: {e}\")\n</code></pre>"},{"location":"api/database/#gsql.database.Database.create_savepoint","title":"<code>create_savepoint(tid, name)</code>","text":"<p>Cr\u00e9e un savepoint dans une transaction</p> Source code in <code>gsql/database.py</code> <pre><code>def create_savepoint(self, tid: int, name: str) -&gt; Dict:\n    \"\"\"Cr\u00e9e un savepoint dans une transaction\"\"\"\n    try:\n        success = self.storage.savepoint(tid, name)\n\n        if tid in self.active_transactions:\n            self.active_transactions[tid]['savepoints'] = \\\n                self.active_transactions[tid].get('savepoints', []) + [name]\n\n        return {\n            'type': 'savepoint',\n            'tid': tid,\n            'name': name,\n            'message': f'Savepoint {name} created in transaction {tid}',\n            'success': success\n        }\n\n    except Exception as e:\n        raise TransactionError(f\"Failed to create savepoint: {e}\")\n</code></pre>"},{"location":"api/database/#gsql.database.Database.create_table","title":"<code>create_table(table_name, columns)</code>","text":"<p>Cr\u00e9e une nouvelle table avec validation</p> Source code in <code>gsql/database.py</code> <pre><code>def create_table(self, table_name: str, columns: Dict) -&gt; Dict:\n    \"\"\"Cr\u00e9e une nouvelle table avec validation\"\"\"\n    try:\n        # Valider le nom de la table\n        if not re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', table_name):\n            raise SQLSyntaxError(f\"Invalid table name: '{table_name}'\")\n\n        # Construire la requ\u00eate SQL\n        column_defs = []\n        for col_name, col_spec in columns.items():\n            if isinstance(col_spec, str):\n                col_def = f\"{col_name} {col_spec}\"\n            elif isinstance(col_spec, dict):\n                col_def = f\"{col_name} {col_spec.get('type', 'TEXT')}\"\n\n                if col_spec.get('primary_key'):\n                    col_def += \" PRIMARY KEY\"\n                if col_spec.get('auto_increment'):\n                    col_def += \" AUTOINCREMENT\"\n                if col_spec.get('not_null'):\n                    col_def += \" NOT NULL\"\n                if 'default' in col_spec:\n                    default_val = col_spec['default']\n                    if isinstance(default_val, str) and not default_val.upper() in ['CURRENT_TIMESTAMP', 'NULL']:\n                        default_val = f\"'{default_val}'\"\n                    col_def += f\" DEFAULT {default_val}\"\n                if col_spec.get('unique'):\n                    col_def += \" UNIQUE\"\n                if 'check' in col_spec:\n                    col_def += f\" CHECK({col_spec['check']})\"\n            else:\n                raise SQLSyntaxError(f\"Invalid column specification for '{col_name}'\")\n\n            column_defs.append(col_def)\n\n        sql = f\"CREATE TABLE {table_name} ({', '.join(column_defs)})\"\n\n        # Ex\u00e9cuter la cr\u00e9ation\n        result = self.execute(sql)\n\n        # Mettre \u00e0 jour le cache de sch\u00e9ma\n        self.storage._cache_table_schema(table_name)\n\n        return {\n            'type': 'create_table',\n            'table': table_name,\n            'columns': list(columns.keys()),\n            'sql': sql,\n            'message': f'Table {table_name} created successfully',\n            'success': True\n        }\n\n    except Exception as e:\n        raise SQLExecutionError(f\"Failed to create table {table_name}: {e}\")\n</code></pre>"},{"location":"api/database/#gsql.database.Database.drop_table","title":"<code>drop_table(table_name, if_exists=True)</code>","text":"<p>Supprime une table</p> Source code in <code>gsql/database.py</code> <pre><code>def drop_table(self, table_name: str, if_exists: bool = True) -&gt; Dict:\n    \"\"\"Supprime une table\"\"\"\n    try:\n        sql = f\"DROP TABLE {'IF EXISTS ' if if_exists else ''}{table_name}\"\n        result = self.execute(sql)\n\n        # Nettoyer le cache\n        if table_name in self.schema_cache:\n            del self.schema_cache[table_name]\n\n        return {\n            'type': 'drop_table',\n            'table': table_name,\n            'message': f'Table {table_name} dropped',\n            'success': True\n        }\n\n    except Exception as e:\n        raise SQLExecutionError(f\"Failed to drop table {table_name}: {e}\")\n</code></pre>"},{"location":"api/database/#gsql.database.Database.execute","title":"<code>execute(sql, params=None, use_cache=True, timeout=None)</code>","text":"<p>Ex\u00e9cute une requ\u00eate SQL sur la base de donn\u00e9es</p> <p>Parameters:</p> Name Type Description Default <code>sql</code> <code>str</code> <p>Requ\u00eate SQL \u00e0 ex\u00e9cuter</p> required <code>params</code> <code>Dict</code> <p>Param\u00e8tres pour la requ\u00eate pr\u00e9par\u00e9e</p> <code>None</code> <code>use_cache</code> <code>bool</code> <p>Utiliser le cache de requ\u00eates</p> <code>True</code> <code>timeout</code> <code>int</code> <p>Timeout en secondes</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict</code> <p>R\u00e9sultats format\u00e9s de la requ\u00eate</p> Source code in <code>gsql/database.py</code> <pre><code>def execute(self, sql: str, params: Dict = None,\n            use_cache: bool = True, timeout: int = None) -&gt; Dict:\n    \"\"\"\n    Ex\u00e9cute une requ\u00eate SQL sur la base de donn\u00e9es\n\n    Args:\n        sql: Requ\u00eate SQL \u00e0 ex\u00e9cuter\n        params: Param\u00e8tres pour la requ\u00eate pr\u00e9par\u00e9e\n        use_cache: Utiliser le cache de requ\u00eates\n        timeout: Timeout en secondes\n\n    Returns:\n        Dict: R\u00e9sultats format\u00e9s de la requ\u00eate\n    \"\"\"\n    if not self.is_open:\n        raise SQLExecutionError(\"Database is closed\")\n\n    # D\u00e9tecter les commandes sp\u00e9ciales GSQL\n    special_result = self._handle_special_commands(sql)\n    if special_result:\n        return special_result\n\n    # D\u00e9tecter les commandes sp\u00e9ciales GSQL\n    special_result = self._handle_special_commands(sql)\n    if special_result:\n        return special_result\n    start_time = datetime.now()\n    query_hash = None\n\n    # G\u00e9n\u00e9rer un hash pour le cache\n    if use_cache and params is None:\n        query_hash = hashlib.md5(sql.encode()).hexdigest()[:16]\n        cached = self.query_cache.get(query_hash)\n        if cached:\n            self.stats['queries_cached'] += 1\n            logger.debug(f\"Query cache hit: {query_hash}\")\n            return cached\n\n    try:\n        with self.lock:\n            # D\u00e9terminer le type de requ\u00eate bas\u00e9 sur le SQL\n            sql_upper = sql.upper().strip()\n            if sql_upper.startswith('SELECT'):\n                query_type = 'select'\n            elif sql_upper.startswith('INSERT'):\n                query_type = 'insert'\n            elif sql_upper.startswith('UPDATE'):\n                query_type = 'update'\n            elif sql_upper.startswith('DELETE'):\n                query_type = 'delete'\n            elif sql_upper.startswith('CREATE'):\n                query_type = 'create'\n            elif sql_upper.startswith('DROP'):\n                query_type = 'drop'\n            elif sql_upper.startswith('ALTER'):\n                query_type = 'alter'\n            elif sql_upper.startswith('BEGIN'):\n                query_type = 'begin'\n            elif sql_upper.startswith('COMMIT'):\n                query_type = 'commit'\n            elif sql_upper.startswith('ROLLBACK'):\n                query_type = 'rollback'\n            else:\n                query_type = 'unknown'\n\n            # Ex\u00e9cuter la requ\u00eate via le storage\n            result = self.storage.execute(sql, params)\n\n            # Ajouter des m\u00e9tadonn\u00e9es\n            execution_time = (datetime.now() - start_time).total_seconds()\n            result['execution_time'] = round(execution_time, 3)\n            result['timestamp'] = datetime.now().isoformat()\n\n            # Ajouter le type de requ\u00eate au r\u00e9sultat\n            result['type'] = query_type\n\n            # Mettre \u00e0 jour les statistiques\n            self.stats['queries_executed'] += 1\n\n            # Mettre en cache les requ\u00eates SELECT r\u00e9ussies\n            if (use_cache and query_hash and \n                result.get('success') and \n                query_type == 'select'):\n\n                # Limiter la taille du cache\n                if len(self.query_cache) &gt;= self.config['max_query_cache']:\n                    # Supprimer la plus ancienne entr\u00e9e\n                    oldest_key = min(self.query_cache.keys(), \n                                    key=lambda k: self.query_cache[k]['timestamp'])\n                    del self.query_cache[oldest_key]\n\n                self.query_cache[query_hash] = result\n\n            # Logger les requ\u00eates importantes\n            if execution_time &gt; 1.0:  # Plus d'1 seconde\n                logger.warning(f\"Slow query ({execution_time:.2f}s): {sql[:100]}...\")\n\n            return result\n\n    except SQLExecutionError as e:\n        self.stats['errors'] += 1\n        logger.error(f\"Query execution error: {e}\")\n\n        # Tentative de r\u00e9cup\u00e9ration pour certaines erreurs\n        if \"database is locked\" in str(e) and self.config['auto_recovery']:\n            logger.info(\"Database locked, attempting recovery...\")\n            self._auto_recover()\n\n            # R\u00e9essayer la requ\u00eate\n            return self.execute(sql, params, use_cache=False)\n\n        raise\n\n    except Exception as e:\n        self.stats['errors'] += 1\n        logger.error(f\"Unexpected error: {e}\")\n        raise SQLExecutionError(f\"Database error: {str(e)}\")\n</code></pre>"},{"location":"api/database/#gsql.database.Database.insert","title":"<code>insert(table_name, values, returning=None)</code>","text":"<p>Ins\u00e8re une ligne dans une table</p> Source code in <code>gsql/database.py</code> <pre><code>def insert(self, table_name: str, values: Dict, \n           returning: str = None) -&gt; Dict:\n    \"\"\"Ins\u00e8re une ligne dans une table\"\"\"\n    try:\n        # Construire la requ\u00eate INSERT\n        columns = ', '.join(values.keys())\n        placeholders = ', '.join(['?' for _ in values])\n\n        sql = f\"INSERT INTO {table_name} ({columns}) VALUES ({placeholders})\"\n\n        if returning:\n            sql += f\" RETURNING {returning}\"\n\n        # Ex\u00e9cuter avec les valeurs\n        result = self.execute(sql, tuple(values.values()))\n\n        return {\n            'type': 'insert',\n            'table': table_name,\n            'lastrowid': result.get('lastrowid'),\n            'rows_affected': result.get('rows_affected', 0),\n            'message': f'Row inserted into {table_name}',\n            'success': True\n        }\n\n    except Exception as e:\n        raise SQLExecutionError(f\"Failed to insert into {table_name}: {e}\")\n</code></pre>"},{"location":"api/database/#gsql.database.Database.optimize","title":"<code>optimize()</code>","text":"<p>Optimise la base de donn\u00e9es</p> Source code in <code>gsql/database.py</code> <pre><code>def optimize(self) -&gt; Dict:\n    \"\"\"Optimise la base de donn\u00e9es\"\"\"\n    try:\n        # Ex\u00e9cuter plusieurs optimisations\n        results = []\n\n        # 1. VACUUM\n        vacuum_result = self._execute_vacuum()\n        results.append(('vacuum', vacuum_result['success']))\n\n        # 2. ANALYZE pour les statistiques\n        analyze_result = self.execute(\"ANALYZE\")\n        results.append(('analyze', analyze_result.get('success', False)))\n\n        # 3. Nettoyer le cache\n        self.query_cache.clear()\n        results.append(('clear_cache', True))\n\n        # 4. Nettoyer le buffer pool\n        self.storage.buffer_pool.invalidate()\n        results.append(('clear_buffer_pool', True))\n\n        return {\n            'type': 'optimize',\n            'operations': results,\n            'message': 'Database optimization completed',\n            'success': all(r[1] for r in results)\n        }\n\n    except Exception as e:\n        return {\n            'type': 'optimize',\n            'message': f'Error during optimization: {e}',\n            'success': False\n        }\n</code></pre>"},{"location":"api/database/#gsql.database.Database.register_function","title":"<code>register_function(name, func, num_params=-1)</code>","text":"<p>Enregistre une fonction Python dans la base</p> Source code in <code>gsql/database.py</code> <pre><code>def register_function(self, name: str, func, num_params: int = -1) -&gt; Dict:\n    \"\"\"Enregistre une fonction Python dans la base\"\"\"\n    try:\n        self.storage.register_function(name, func, num_params)\n\n        return {\n            'type': 'register_function',\n            'name': name,\n            'num_params': num_params,\n            'message': f'Function {name} registered',\n            'success': True\n        }\n\n    except Exception as e:\n        raise FunctionError(f\"Failed to register function {name}: {e}\")\n</code></pre>"},{"location":"api/database/#gsql.database.Database.rollback_transaction","title":"<code>rollback_transaction(tid, to_savepoint=None)</code>","text":"<p>Annule une transaction</p> Source code in <code>gsql/database.py</code> <pre><code>def rollback_transaction(self, tid: int, to_savepoint: str = None) -&gt; Dict:\n    \"\"\"Annule une transaction\"\"\"\n    try:\n        success = self.storage.rollback_transaction(tid, to_savepoint)\n\n        if not to_savepoint and tid in self.active_transactions:\n            del self.active_transactions[tid]\n\n        return {\n            'type': 'transaction',\n            'tid': tid,\n            'message': f'Transaction {tid} rolled back' + \n                      (f' to {to_savepoint}' if to_savepoint else ''),\n            'success': success\n        }\n\n    except Exception as e:\n        raise TransactionError(f\"Failed to rollback transaction {tid}: {e}\")\n</code></pre>"},{"location":"api/database/#gsql.database.Database.select","title":"<code>select(table_name, columns=None, where=None, limit=None, offset=0, order_by=None)</code>","text":"<p>Ex\u00e9cute une requ\u00eate SELECT avec param\u00e8tres simplifi\u00e9s</p> Source code in <code>gsql/database.py</code> <pre><code>def select(self, table_name: str, columns: List[str] = None, \n           where: Dict = None, limit: int = None, \n           offset: int = 0, order_by: str = None) -&gt; Dict:\n    \"\"\"Ex\u00e9cute une requ\u00eate SELECT avec param\u00e8tres simplifi\u00e9s\"\"\"\n    try:\n        # Construire la requ\u00eate SELECT\n        cols = ', '.join(columns) if columns else '*'\n        sql = f\"SELECT {cols} FROM {table_name}\"\n\n        # Ajouter WHERE\n        params = []\n        if where:\n            conditions = []\n            for col, val in where.items():\n                if isinstance(val, (list, tuple)):\n                    placeholders = ', '.join(['?' for _ in val])\n                    conditions.append(f\"{col} IN ({placeholders})\")\n                    params.extend(val)\n                else:\n                    conditions.append(f\"{col} = ?\")\n                    params.append(val)\n\n            if conditions:\n                sql += f\" WHERE {' AND '.join(conditions)}\"\n\n        # Ajouter ORDER BY\n        if order_by:\n            sql += f\" ORDER BY {order_by}\"\n\n        # Ajouter LIMIT et OFFSET\n        if limit is not None:\n            sql += f\" LIMIT {limit}\"\n            if offset:\n                sql += f\" OFFSET {offset}\"\n\n        # Ex\u00e9cuter la requ\u00eate\n        result = self.execute(sql, params if params else None)\n\n        return result\n\n    except Exception as e:\n        raise SQLExecutionError(f\"Failed to select from {table_name}: {e}\")\n</code></pre>"},{"location":"api/database/#gsql.database.connect","title":"<code>connect(db_path, **kwargs)</code>","text":"<p>Connecte \u00e0 une base de donn\u00e9es GSQL (alias pour create_database)</p> Source code in <code>gsql/database.py</code> <pre><code>def connect(db_path: str, **kwargs) -&gt; Database:\n    \"\"\"Connecte \u00e0 une base de donn\u00e9es GSQL (alias pour create_database)\"\"\"\n    return create_database(db_path, **kwargs)\n</code></pre>"},{"location":"api/database/#gsql.database.create_database","title":"<code>create_database(db_path=None, **kwargs)</code>","text":"<p>Cr\u00e9e une nouvelle instance de base de donn\u00e9es Accepte 'path' comme alias pour 'db_path' pour la compatibilit\u00e9</p> Source code in <code>gsql/database.py</code> <pre><code>def create_database(db_path=None, **kwargs) -&gt; Database:\n    \"\"\"\n    Cr\u00e9e une nouvelle instance de base de donn\u00e9es\n    Accepte 'path' comme alias pour 'db_path' pour la compatibilit\u00e9\n    \"\"\"\n    # Si 'path' est fourni dans kwargs, l'utiliser comme db_path\n    if 'path' in kwargs:\n        db_path = kwargs.pop('path')\n\n    return Database(db_path, **kwargs)\n</code></pre>"},{"location":"api/database/#gsql.database.get_default_database","title":"<code>get_default_database()</code>","text":"<p>R\u00e9cup\u00e8re l'instance de base de donn\u00e9es par d\u00e9faut</p> Source code in <code>gsql/database.py</code> <pre><code>def get_default_database() -&gt; Optional[Database]:\n    \"\"\"R\u00e9cup\u00e8re l'instance de base de donn\u00e9es par d\u00e9faut\"\"\"\n    # Cette fonction peut g\u00e9rer une instance globale\n    if not hasattr(get_default_database, '_instance'):\n        get_default_database._instance = None\n\n    return get_default_database._instance\n</code></pre>"},{"location":"api/database/#gsql.database.set_default_database","title":"<code>set_default_database(db)</code>","text":"<p>D\u00e9finit l'instance de base de donn\u00e9es par d\u00e9faut</p> Source code in <code>gsql/database.py</code> <pre><code>def set_default_database(db: Database):\n    \"\"\"D\u00e9finit l'instance de base de donn\u00e9es par d\u00e9faut\"\"\"\n    get_default_database._instance = db\n</code></pre>"}]}